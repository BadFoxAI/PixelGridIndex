<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Data Interconverter</title>
  <style>
    :root { /* CSS Variables */
      --primary-bg: #f4f6f8; --secondary-bg: #ffffff; --text-color: #2c3e50; --label-color: #5a6573;
      --input-border: #ced4da; --input-focus-border: #007bff; --accent-color: #007bff;
      --accent-hover-color: #0056b3; --danger-color: #e74c3c; --shadow-color: rgba(0,0,0,0.06);
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      --monospace-font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
      --container-max-width: 1800px; --controls-max-width: 430px; --border-radius: 5px;
    }
    html, body { height:100%; margin:0; overflow:hidden; }
    body { font-family:var(--font-family); background-color:var(--primary-bg); color:var(--text-color); display:flex; flex-direction:column; font-size:15px; line-height:1.65; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    .container { display:flex; flex-direction:column; flex-grow:1; max-width:var(--container-max-width); margin:0 auto; width:100%; overflow:hidden; }
    header { background:var(--accent-color); color:white; padding:12px 20px; text-align:center; box-shadow:0 2px 3px var(--shadow-color); flex-shrink:0; }
    header h1 { margin:0; font-size:1.5em; font-weight:500; }
    main { display:flex; flex-grow:1; padding:15px; gap:15px; overflow:hidden; height:calc(100vh - 49px - 57px); }
    .panel { background-color:var(--secondary-bg); padding:20px; border-radius:var(--border-radius); box-shadow:0 1px 2px var(--shadow-color); display:flex; flex-direction:column; gap:15px; overflow-y:auto; scrollbar-width:thin; scrollbar-color:var(--input-border) var(--secondary-bg); }
    .panel::-webkit-scrollbar { width:8px; } .panel::-webkit-scrollbar-track { background:var(--secondary-bg); } .panel::-webkit-scrollbar-thumb { background-color:var(--input-border); border-radius:4px; border:2px solid var(--secondary-bg); }
    .controls-section { flex:0 0 var(--controls-max-width); min-width:300px; }
    .visualization-section { flex:1 1 50%; align-items:center; justify-content:center; display:flex; flex-direction:column; min-height:0; padding:0; min-width:300px; }
    .sequence-panel { flex: 1 1 calc(50% - var(--controls-max-width) - 30px); min-width:300px; }
    @media (max-width:1200px) { main { flex-wrap: wrap; } .visualization-section { flex-basis: calc(60% - 7.5px); order: 1;} .sequence-panel { flex-basis: calc(40% - 7.5px); order: 2;} .controls-section { flex-basis: 100%; order: 3; max-width: 100%;} }
    @media (max-width:768px) { main { flex-direction:column; overflow-y:auto; height:auto; } .visualization-section { order: 1; min-height: 35vh;} .sequence-panel { order: 2; min-height: 30vh; } .controls-section { order: 3; } .container{padding:0;} header{border-radius:0;} }
    h2, h3 { margin-top:0; color:var(--accent-hover-color); border-bottom:1px solid #e8e8e8; padding-bottom:8px; font-size:1.25em; font-weight:500; }
    h3 { font-size: 1.1em; margin-bottom: 10px; }
    .control-group label { margin-bottom:5px; font-weight:500; color:var(--label-color); font-size:0.9em; }
    .control-group input[type="text"], .control-group input[type="number"], .control-group input[type="file"], .control-group textarea, .control-group select, .control-group button { padding:9px 10px; font-size:0.9em; border-radius:calc(var(--border-radius) - 1px); border:1px solid var(--input-border); box-sizing:border-box; width:100%; }
    .control-group button { background-color:var(--accent-color); color:white; cursor:pointer; transition:background-color 0.2s ease; }
    .control-group button:hover:not(:disabled) { background-color:var(--accent-hover-color); } .control-group button:disabled { background-color:#ccc; cursor:not-allowed; }
    .control-group input[type="text"]:focus, .control-group input[type="number"]:focus, .control-group textarea:focus, .control-group select:focus { border-color:var(--input-focus-border); outline:none; box-shadow:0 0 0 0.15rem rgba(0,123,255,0.2); }
    .control-group textarea { min-height:100px; resize:vertical; font-family:var(--monospace-font-family); white-space:pre-wrap; }
    .control-group small { font-size:0.75em; color:#888; margin-top:5px; display:block; }
    .inline-controls { display:flex; gap:10px; align-items:center; margin-bottom:8px;} .inline-controls label { margin-bottom:0; flex-shrink:0; } .inline-controls input[type="number"], .inline-controls select { width:auto; flex-grow:1; }
    .pixel-grid-container { width:100%; height:calc(100% - 50px); display:flex; justify-content:center; align-items:center; background-color:#e9eff3; border-radius:var(--border-radius); overflow:hidden; position:relative; box-sizing:border-box; padding:10px; }
    #mainImageCanvas { max-width:100%; max-height:100%; image-rendering:pixelated; image-rendering:-moz-crisp-edges; image-rendering:crisp-edges; background-color:#fff; box-shadow:0 0 5px rgba(0,0,0,0.08); display:block; opacity:1; }
    #mainImageStatus { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; color:#555; padding:10px 15px; font-style:italic; font-size:0.95em; z-index:10; background-color:rgba(255,255,255,0.9); border-radius:calc(var(--border-radius) - 2px); box-shadow:0 1px 2px var(--shadow-color); }
    #sequencePanelInfo { font-size: 0.85em; color: #666; margin-top: 10px;}
    footer { background-color:#343a40; color:#bdc3c7; padding:15px; text-align:center; font-size:0.9em; flex-shrink:0;}
    .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.45); justify-content:center; align-items:center; }
    .modal-content { background-color:#fefefe; margin:auto; padding:25px; border:1px solid #bbb; width:90%; max-width:420px; border-radius:var(--border-radius); text-align:center; box-shadow:0 4px 15px rgba(0,0,0,0.2); }
    .modal-content h3 { margin-top:0; margin-bottom:12px; font-size:1.2em; color:var(--accent-hover-color); } .modal-content p { font-size:0.95em; margin-bottom:20px; line-height:1.5; }
    .modal-buttons button { margin-top:10px; padding:9px 18px; background-color:var(--accent-color); color:white; border:none; border-radius:calc(var(--border-radius) - 1px); cursor:pointer; font-size:0.9em; transition:background-color 0.2s ease;}
    .modal-buttons button:hover { background-color:var(--accent-hover-color); }
    #loadingOverlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.65); z-index:2000; justify-content:center; align-items:center; flex-direction:column; color:white; font-size:1.2em; text-align:center; }
    #loadingOverlay .spinner { border:8px solid #f3f3f3; border-top:8px solid var(--accent-color); border-radius:50%; width:60px; height:60px; animation:spin 1s linear infinite; margin-top:20px; }
    @keyframes spin { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
  </style>
</head>
<body>
  <div class="container">
    <header><h1>Data Interconverter</h1></header>
    <main>
      <section class="panel controls-section">
        <h2>Input & Controls</h2>
        <div class="control-group"> <label for="canonicalIndexInput">Canonical Index (BigInt):</label> <textarea id="canonicalIndexInput" rows="3" placeholder="0"></textarea> <small>Arbitrary-precision non-negative integer. Non-digits are ignored.</small> </div>
        <div class="control-group"> <label for="textInput">Text Data:</label> <textarea id="textInput" placeholder="Enter text..."></textarea> <small>Uses a programmer-focused character set (<span id="charSetSizeDisplay">0</span> chars).</small> </div>
        <h3>Image Modality</h3>
        <div class="control-group"> <label for="imageUploadInput">Upload Image for Indexing:</label> <input type="file" id="imageUploadInput" accept="image/*"> <small>System-generated PNGs re-import losslessly using filename metadata (dimensions, channels, BPC, significant length). Others processed using current UI C/BPC.</small> </div>
        <div class="control-group inline-controls"> <label for="imageChannelsSelect">Channels (CI ↔ Img):</label> <select id="imageChannelsSelect"> <option value="1">1 (Grayscale)</option> <option value="3" selected>3 (RGB)</option> <option value="4">4 (RGBA)</option> </select> </div>
        <div class="control-group inline-controls"> <label for="imageBpcSelect">Bits/Channel (CI ↔ Img):</label> <select id="imageBpcSelect"> <option value="1">1</option> <option value="2">2</option> <option value="4">4</option> <option value="8" selected>8</option> </select> </div>
        <small>Above params affect how CI is decoded to image, and how uploaded arbitrary image pixels are interpreted. System PNGs override these with their filename metadata.</small>
      </section>

      <section class="panel visualization-section">
        <h2>Main Image View (<span id="mainImageDimensionsDisplay">1x1</span>)</h2>
        <div class="pixel-grid-container" id="pixelGridContainer"> 
             <canvas id="mainImageCanvas"></canvas> 
             <p id="mainImageStatus">Enter data or upload an image.</p> 
        </div>
        <div class="control-group" style="margin-top: 10px; text-align: center; width: auto; max-width: 250px; margin-left: auto; margin-right: auto;">
            <button id="downloadImagePNGButton">Download Image as PNG</button>
        </div>
      </section>

      <section class="panel sequence-panel">
        <h2>Numerical Sequence (24-bit elements)</h2>
        <div class="control-group">
            <label for="sequenceInput">Sequence (Input / Canonical Output):</label>
            <textarea id="sequenceInput" placeholder="e.g., 16711680, 65280, 255"></textarea>
            <small>Comma-separated values. Reflects the current Canonical Index as a sequence of 24-bit numbers.</small>
        </div>
        <div id="sequencePanelInfo">Canonical Length: <span id="sequenceCanonicalLengthDisplay">0</span> elements</div>
        <div class="control-group" style="margin-top: auto;">
             <button id="saveSequenceRawBinaryButton">Save Sequence as Raw Binary</button>
        </div>
        <div class="control-group">
            <label for="loadSequenceRawBinaryInput">Load Sequence from Raw Binary:</label>
            <input type="file" id="loadSequenceRawBinaryInput" accept=".seqbin,.bin,.dat,application/octet-stream">
            <small>Filename should contain _N<length>_B24 metadata.</small>
        </div>
      </section>
    </main>
    <footer> <p>Data Interconverter</p> </footer>
  </div>
  <div class="modal" id="errorModalElement"> <div class="modal-content"> <h3 id="errorModalTitleElement">Notification</h3> <p id="errorModalMessageElement"></p> <div class="modal-buttons"> <button id="errorModalOkButtonElement">OK</button> </div> </div> </div>
  <div id="loadingOverlay"> <p id="loadingMessage">Processing...</p> <div class="spinner"></div> </div>

<script>
    // --- Configuration ---
    const PROGRAMMER_CHAR_SET_STRING = " \n\t\r"+"abcdefghijklmnopqrstuvwxyz"+"ABCDEFGHIJKLMNOPQRSTUVWXYZ"+"0123456789"+"!\"#$%&'()*+,-./:;<=>?@"+"[\\]^_`{|}~"+"←↑→↓↔"+"∑√≈≠≤≥÷±∞"+"€₹₽£¥₩"+"¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿"+"ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß"+"àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ";
    const CONFIG = {
        CHAR_SET_STRING: PROGRAMMER_CHAR_SET_STRING, 
        IMAGE_UPLOAD_MAX_SOURCE_DRAW_DIM: 1024, 
        DEFAULT_IMAGE_CHANNELS:3, DEFAULT_IMAGE_BPC:8, NUM_SEQUENCE_ELEMENT_BIT_WIDTH:24, 
        DEBOUNCE_DELAY_INPUT:350, DEBOUNCE_DELAY_TEXT_AREA:400, MAX_CANVAS_DIM_ESTIMATE:8192, LOADER_FLICKER_THRESHOLD: 300,
        PIXEL_PROCESSING_CHUNK_SIZE: 2048, // Number of source RGBA pixels to process per chunk
    }; Object.freeze(CONFIG);
    const CHAR_SET_Array = Array.from(new Set(CONFIG.CHAR_SET_STRING.split(''))).sort();
    const CHAR_SET_Base = BigInt(CHAR_SET_Array.length);
    const SEQUENCE_Element_Bit_Width = BigInt(CONFIG.NUM_SEQUENCE_ELEMENT_BIT_WIDTH);
    const SEQUENCE_Element_Base = 2n**SEQUENCE_Element_Bit_Width;
    const SEQUENCE_Max_Val_BigInt = SEQUENCE_Element_Base - 1n;

    // --- DOM Elements Cache ---
    const dom = { 
        canonicalIndexInput: document.getElementById('canonicalIndexInput'), 
        textInput: document.getElementById('textInput'), 
        charSetSizeDisplay: document.getElementById('charSetSizeDisplay'), 
        imageUploadInput: document.getElementById('imageUploadInput'), 
        imageChannelsSelect: document.getElementById('imageChannelsSelect'), 
        imageBpcSelect: document.getElementById('imageBpcSelect'), 
        mainImageCanvas: document.getElementById('mainImageCanvas'), 
        mainImageDimensionsDisplay: document.getElementById('mainImageDimensionsDisplay'), 
        mainImageStatus: document.getElementById('mainImageStatus'), 
        pixelGridContainer: document.getElementById('pixelGridContainer'), 
        downloadImagePNGButton: document.getElementById('downloadImagePNGButton'), 
        sequenceInput: document.getElementById('sequenceInput'), 
        sequenceCanonicalLengthDisplay: document.getElementById('sequenceCanonicalLengthDisplay'), 
        saveSequenceRawBinaryButton: document.getElementById('saveSequenceRawBinaryButton'), 
        loadSequenceRawBinaryInput: document.getElementById('loadSequenceRawBinaryInput'), 
        errorModal:{el:document.getElementById('errorModalElement'),title:document.getElementById('errorModalTitleElement'),message:document.getElementById('errorModalMessageElement'),okButton:document.getElementById('errorModalOkButtonElement')}, 
        loadingOverlay:document.getElementById('loadingOverlay'), 
        loadingMessage:document.getElementById('loadingMessage'), 
    };
    const mainImageCtx = dom.mainImageCanvas.getContext('2d',{alpha:true,willReadFrequently:true});
    
    // --- Application State ---
    let appState = { 
        canonicalIndex:0n, 
        sourceOfChange:'initialLoad', 
        imageDecodeParams:{ 
            channels:CONFIG.DEFAULT_IMAGE_CHANNELS,
            bitsPerChannel:CONFIG.DEFAULT_IMAGE_BPC,
        }, 
        lastDirectInputSequence: null, 
    };
    
    // --- Utility Functions ---
    function showErrorModal(title,message){dom.errorModal.title.textContent=title;dom.errorModal.message.textContent=message;dom.errorModal.el.style.display='flex';}
    dom.errorModal.okButton.onclick=()=>{dom.errorModal.el.style.display='none';};
    window.addEventListener('click',(event)=>{if(event.target===dom.errorModal.el)dom.errorModal.el.style.display='none';});
    function debounce(func,delay){let timeout;return function(...args){clearTimeout(timeout);timeout=setTimeout(()=>func.apply(this,args),delay);};}
    let generalUpdateLoaderTimeoutId = null;
    function showLoader(message = "Processing...", forceImmediate = false) { clearTimeout(generalUpdateLoaderTimeoutId); if (forceImmediate) { dom.loadingMessage.textContent = message; dom.loadingOverlay.style.display = 'flex'; } else { generalUpdateLoaderTimeoutId = setTimeout(() => { dom.loadingMessage.textContent = message; dom.loadingOverlay.style.display = 'flex'; }, CONFIG.LOADER_FLICKER_THRESHOLD); } }
    function hideLoader() { clearTimeout(generalUpdateLoaderTimeoutId); dom.loadingOverlay.style.display = 'none'; }
    function safeParseBigInt(str){try{if(typeof str !=='string')str=String(str);const numericStr=str.replace(/[^0-9]/g,'');return numericStr===""?0n:BigInt(numericStr);}catch(e){return null;}}
    
    // --- Text Conversion ---
    function textToIndex(text){let index=0n;if(!text)return 0n;for(let i=0;i<text.length;i++){const charVal=CHAR_SET_Array.indexOf(text[i]);if(charVal===-1){throw new Error(`Character '${text[i]}' (Unicode ${text[i].charCodeAt(0)}) at pos ${i} not in char set.`);}index=index*CHAR_SET_Base+BigInt(charVal);}return index;}
    function indexToText(index){if(index===0n)return "";let text="";let tempIndex=BigInt(index);if(tempIndex<0n)throw new Error("Negative index to text conversion is not supported.");while(tempIndex>0n){const charIndex=Number(tempIndex%CHAR_SET_Base);text=(CHAR_SET_Array[charIndex]!==undefined?CHAR_SET_Array[charIndex]:'?')+text;tempIndex/=CHAR_SET_Base;}return text;}
    
    // --- Image "Super-Digit" Conversion ---
    function getImagePixelBase(channels,bitsPerChannel){const channelBase=2n**BigInt(bitsPerChannel);return channelBase**BigInt(channels);}
    
    // CHUNKED version of imageDataToPixelArray for improved UI responsiveness.
    function imageDataToPixelArrayChunked(imageData, targetChannels, targetBPC, progressCallback, completionCallback) {
        const { data } = imageData;
        const pixels = [];
        const sourceBPC = 8;
        const sourceChannelMaxVal = 255;
        const targetChannelMaxVal = (1 << targetBPC) - 1;
        const channelValueBaseForSuperDigit = 2n ** BigInt(targetBPC);

        let currentIndexInDataArray = 0; // Current index in the raw 'data' array (increments by 4)
        const chunkSizeInPixels = CONFIG.PIXEL_PROCESSING_CHUNK_SIZE; // Number of source RGBA pixels to process per chunk

        function processChunk() {
            const limitInDataArray = Math.min(currentIndexInDataArray + chunkSizeInPixels * 4, data.length);
            for (let i = currentIndexInDataArray; i < limitInDataArray; i += 4) {
                let pixelSuperDigitValue = 0n;
                for (let c = 0; c < targetChannels; c++) {
                    let channelComponentValue;
                    if (targetChannels === 1) {
                        channelComponentValue = Math.round((data[i] + data[i + 1] + data[i + 2]) / 3);
                    } else if (c < 3) {
                        channelComponentValue = data[i + c];
                    } else {
                        channelComponentValue = data[i + 3];
                    }
                    if (targetBPC !== sourceBPC) {
                        if (targetChannelMaxVal > 0) {
                            channelComponentValue = Math.round(channelComponentValue * (targetChannelMaxVal / sourceChannelMaxVal));
                        } else if (targetBPC === 0 && channelComponentValue > 0) {
                            channelComponentValue = 1;
                        } else {
                            channelComponentValue = 0;
                        }
                    }
                    channelComponentValue = Math.min(Math.max(0, channelComponentValue), targetChannelMaxVal);
                    pixelSuperDigitValue = pixelSuperDigitValue * channelValueBaseForSuperDigit + BigInt(channelComponentValue);
                }
                pixels.push(pixelSuperDigitValue);
            }
            currentIndexInDataArray = limitInDataArray;

            if (currentIndexInDataArray < data.length) {
                if (progressCallback) {
                    progressCallback(Math.round((currentIndexInDataArray / data.length) * 100));
                }
                setTimeout(processChunk, 0); // Yield to main thread
            } else {
                if (progressCallback) {
                    progressCallback(100);
                }
                completionCallback(pixels); // All done
            }
        }
        if (data.length === 0) { // Handle empty imagedata immediately
            completionCallback([]);
            return;
        }
        processChunk(); // Start processing
    }

    function imagePixelsToIndex(pixelValueArray,channels,bitsPerChannel){
        let index=0n;
        if(!pixelValueArray||pixelValueArray.length===0)return 0n;
        const pixelBase=getImagePixelBase(channels,bitsPerChannel);
        if(pixelBase<=0n && pixelValueArray.some(p => p !== 0n)) {
             throw new Error(`Pixel base is ${pixelBase}, cannot represent non-zero pixel values.`);
        }
        if(pixelBase === 1n && pixelValueArray.some(p => p >= 1n)) {
            throw new Error(`Pixel value found >= 1 for pixel base 1. This configuration is likely problematic.`);
        }
        for(const pixelVal of pixelValueArray){
            if (pixelVal < 0n || (pixelBase > 0n && pixelVal >= pixelBase) ) { 
                 throw new Error(`Pixel value ${pixelVal} is out of range for base ${pixelBase} (derived from ${channels}ch @ ${bitsPerChannel}bpc).`);
            }
            index=index*pixelBase+BigInt(pixelVal);
        }
        return index;
    }
    function indexToImagePixelArray(index,numPixels,channels,bitsPerChannel){
        const pixelValues=[];
        if(numPixels<=0)return pixelValues; 
        const pixelBase=getImagePixelBase(channels,bitsPerChannel);
        if(pixelBase <= 0n && index !== 0n) {
            throw new Error(`Cannot represent non-zero index ${index} with pixel base ${pixelBase}.`);
        }
        if(pixelBase === 1n && index !== 0n && numPixels > 0) {
             throw new Error(`Index ${index} is invalid for pixel base 1. Only index 0 is representable with ${numPixels} pixels.`);
        }
        let tempIndex=BigInt(index);
        for(let i=0;i<numPixels;i++){
            if (pixelBase > 0n) {
                 pixelValues.unshift(tempIndex%pixelBase); 
                 tempIndex/=pixelBase;
            } else { 
                 pixelValues.unshift(0n); 
            }
        }
        if (tempIndex > 0n) {
            throw new Error(`Index ${index} is too large to be represented by ${numPixels} pixels with base ${pixelBase}.`);
        }
        return pixelValues;
    }
    function pixelArrayToImageData(pixelValueArray,width,height,targetChannels,targetBPC){ 
        const outputImageData=mainImageCtx.createImageData(width,height); 
        const data=outputImageData.data; 
        const outputBPC = 8; 
        const outputChannelMaxVal = 255; 
        const targetChannelMaxVal = (1 << targetBPC) - 1; 
        const channelValueBaseForSuperDigit = 2n ** BigInt(targetBPC); 
        for(let i=0; i < width*height; i++){ 
            const dataIdx=i*4; 
            let currentPixelSuperDigit = 0n;
            if (i < pixelValueArray.length) {
                currentPixelSuperDigit = BigInt(pixelValueArray[i]);
            } else {
                currentPixelSuperDigit = 0n; 
            }
            let r=0,g=0,b=0,a=255; 
            const channelComponents = []; 
            for (let c = 0; c < targetChannels; c++) { 
                if (channelValueBaseForSuperDigit > 0n) { 
                    channelComponents.unshift(Number(currentPixelSuperDigit % channelValueBaseForSuperDigit)); 
                    currentPixelSuperDigit /= channelValueBaseForSuperDigit; 
                } else { 
                    channelComponents.unshift(0); 
                }
            } 
            if (targetChannels === 1) { 
                let grayVal = channelComponents[0] || 0; 
                if (targetBPC !== outputBPC && targetChannelMaxVal > 0) { 
                    grayVal = Math.round(grayVal * (outputChannelMaxVal / targetChannelMaxVal)); 
                } 
                r = g = b = Math.min(Math.max(0, grayVal), 255); 
            } else { 
                r = channelComponents[0] || 0; 
                g = channelComponents[1] || 0; 
                b = channelComponents[2] || 0; 
                if (targetChannels === 4) { a = channelComponents[3] || 0; } 
                if (targetBPC !== outputBPC && targetChannelMaxVal > 0) { 
                    r = Math.round(r * (outputChannelMaxVal / targetChannelMaxVal)); 
                    g = Math.round(g * (outputChannelMaxVal / targetChannelMaxVal)); 
                    b = Math.round(b * (outputChannelMaxVal / targetChannelMaxVal)); 
                    if (targetChannels === 4) { a = Math.round(a * (outputChannelMaxVal / targetChannelMaxVal)); } 
                } 
                r = Math.min(Math.max(0, r), 255); 
                g = Math.min(Math.max(0, g), 255); 
                b = Math.min(Math.max(0, b), 255); 
                if (targetChannels === 4) { a = Math.min(Math.max(0, a), 255); }
            } 
            data[dataIdx]=r; data[dataIdx+1]=g; data[dataIdx+2]=b; data[dataIdx+3]=a; 
        } 
        return outputImageData; 
    }
    
    // --- Numerical Sequence (24-bit elements) Conversion & Raw Binary IO ---
    function calculateMinSequenceLength(index) { 
        if (index === 0n) return 0; 
        let length = 0; 
        let tempIndex = BigInt(index); 
        if (tempIndex < 0n) tempIndex = -tempIndex; 
        if (tempIndex === 0n && index !== 0n) return 1; 
        if (tempIndex === 0n) return 0; 
        do { 
            tempIndex /= SEQUENCE_Element_Base; 
            length++; 
        } while (tempIndex > 0n); 
        return length; 
    }
    function sequenceToIndex(sequenceArray){let index=0n;for(const value of sequenceArray){const valBigInt=BigInt(value);if(valBigInt<0n||valBigInt>SEQUENCE_Max_Val_BigInt){throw new Error(`Sequence value ${value} is out of the 0 to ${SEQUENCE_Max_Val_BigInt} range for ${CONFIG.NUM_SEQUENCE_ELEMENT_BIT_WIDTH}-bit elements.`);}index=index*SEQUENCE_Element_Base+valBigInt;}return index;}
    function indexToSequence(index,targetLength){
        if(targetLength<0) throw new Error("Target sequence length cannot be negative.");
        const decodedSequence=[];
        if(targetLength===0 && index===0n) return decodedSequence; 
        if(targetLength===0 && index!==0n) throw new Error("Cannot represent a non-zero index with a target sequence length of 0.");
        let tempIndex=BigInt(index);
        if(tempIndex<0n)throw new Error("Negative index to sequence conversion is not supported.");
        for(let i=0;i<targetLength;i++){
            decodedSequence.unshift(Number(tempIndex%SEQUENCE_Element_Base));
            tempIndex/=SEQUENCE_Element_Base;
        }
        if(tempIndex > 0n) { 
            throw new Error(`Index ${index} is too large to be represented by a sequence of length ${targetLength}.`);
        }
        return decodedSequence;
    }
    function saveSequenceAsRawBinary(){ 
        const currentMinLength = calculateMinSequenceLength(appState.canonicalIndex);
        const sequenceToSave = indexToSequence(appState.canonicalIndex, currentMinLength); 
        if((!sequenceToSave||sequenceToSave.length===0) && appState.canonicalIndex !== 0n){ showErrorModal("Save Error","Cannot save empty sequence for a non-zero index."); return; } 
        const numElements=sequenceToSave.length; 
        const bytesPerElement=Math.ceil(CONFIG.NUM_SEQUENCE_ELEMENT_BIT_WIDTH / 8); 
        showLoader("Generating Raw Binary File...",true); 
        setTimeout(()=>{ try{ 
            const buffer=new ArrayBuffer(numElements*bytesPerElement); 
            const dataView=new DataView(buffer);
            let offset=0; 
            for(const val of sequenceToSave){
                if(val<0||val>Number(SEQUENCE_Max_Val_BigInt)){throw new Error(`Sequence value ${val} is out of range for saving.`);} 
                dataView.setUint8(offset++, (val >> 16) & 0xFF); 
                dataView.setUint8(offset++, (val >> 8) & 0xFF);  
                dataView.setUint8(offset++, val & 0xFF);         
            }
            const blob=new Blob([buffer],{type:'application/octet-stream'}); 
            const link=document.createElement('a'); 
            link.download=`sequence_N${numElements}_B${CONFIG.NUM_SEQUENCE_ELEMENT_BIT_WIDTH}_${Date.now()}.seqbin`; 
            link.href=URL.createObjectURL(blob); document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); 
        }catch(e){showErrorModal("Save Binary Error",e.message);}finally{hideLoader();}},10); 
    }
    function loadSequenceFromRawBinary(file){
        showLoader("Loading Raw Binary File...",true);
        const reader=new FileReader();
        reader.onload=(event)=>{
            showLoader("Processing Binary Data...",true);
            setTimeout(()=>{try{
                const buffer=event.target.result;
                if(!(buffer instanceof ArrayBuffer)){throw new Error("File content is not an ArrayBuffer.");}
                let expectedN=-1; let expectedB=-1;
                const matchN=file.name.match(/_N(\d+)_/); const matchB=file.name.match(/_B(\d+)_/);
                if(matchN&&matchN[1])expectedN=parseInt(matchN[1],10);
                if(matchB&&matchB[1])expectedB=parseInt(matchB[1],10);
                if(isNaN(expectedN)||expectedN<0){throw new Error("Filename metadata for number of elements (N) is missing or invalid.");}
                if(isNaN(expectedB)||expectedB!==CONFIG.NUM_SEQUENCE_ELEMENT_BIT_WIDTH){throw new Error(`Filename metadata for bit width (B) mismatch. Expected ${CONFIG.NUM_SEQUENCE_ELEMENT_BIT_WIDTH}, got ${expectedB}.`);}
                const bytesPerElement=Math.ceil(CONFIG.NUM_SEQUENCE_ELEMENT_BIT_WIDTH / 8);
                if(buffer.byteLength===0 && expectedN===0){  }
                else if(buffer.byteLength !== expectedN*bytesPerElement){ showErrorModal("Load Warning",`File size (${buffer.byteLength} bytes) does not match expected size (${expectedN*bytesPerElement} bytes) from filename metadata. Processing available data.`); }
                const dataView=new DataView(buffer);
                const loadedSeq=[];
                const numElementsToRead=Math.min(expectedN, Math.floor(buffer.byteLength/bytesPerElement)); 
                for(let i=0;i<numElementsToRead;i++){
                    const offset=i*bytesPerElement;
                    if (offset + bytesPerElement > buffer.byteLength) break; 
                    const val=(dataView.getUint8(offset)<<16)|(dataView.getUint8(offset+1)<<8)|dataView.getUint8(offset+2);
                    loadedSeq.push(val);
                }
                if(loadedSeq.length<expectedN && expectedN > 0 && numElementsToRead < expectedN){showErrorModal("Load Warning",`Read ${loadedSeq.length} elements due to file size, but filename expected N=${expectedN}.`);}
                appState.lastDirectInputSequence=loadedSeq.slice();
                appState.canonicalIndex=sequenceToIndex(loadedSeq);
                appState.sourceOfChange='rawBinaryUpload';
                updateAllViews();
            }catch(e){showErrorModal("Load Binary Error",e.message);}finally{hideLoader();dom.loadSequenceRawBinaryInput.value = '';}},10);
        };
        reader.onerror=()=>{showErrorModal("File Read Error","Could not read the selected binary file.");hideLoader();dom.loadSequenceRawBinaryInput.value = '';};
        if(file)reader.readAsArrayBuffer(file); else hideLoader();
    }

    // --- Image Upload & Processing ---
    function calculateOptimalImageDimensions(index,channels,bitsPerChannel){
        if(index===0n)return{width:1,height:1,numPixels:1}; 
        const pixelBase=getImagePixelBase(channels,bitsPerChannel);
        if(pixelBase <= 0n && index !== 0n) {
             throw new Error(`Cannot represent non-zero index with pixel base ${pixelBase}.`);
        }
        if(pixelBase === 1n && index !== 0n) { 
             throw new Error(`Cannot represent non-zero index with pixel base 1 (requires infinite pixels or index 0).`);
        }
        if (pixelBase <= 1n && index === 0n) return {width:1,height:1,numPixels:1};

        let numSignificantPixels=0n;
        let tempIndex=BigInt(index);
        do { 
            if (pixelBase > 0n) tempIndex/=pixelBase; else break; 
            numSignificantPixels++;
        } while(tempIndex>0n);
        if (index === 0n && numSignificantPixels === 0n) numSignificantPixels = 1n; // Ensure index 0 has 1 pixel if loop resulted in 0

        const numPixelsActual = Number(numSignificantPixels);
        const side=Math.ceil(Math.sqrt(numPixelsActual)); 
        let width=side;
        let height=Math.ceil(numPixelsActual/width);
        width = Math.max(1,width);
        height = Math.max(1,height);
        return{width,height,numPixels:numPixelsActual};
    }
    function parseFilenameForSystemImageParams(filename) {
        if (!filename) return null;
        const match = filename.match(/^cimg_(\d+)x(\d+)_c(\d+)b(\d+)(?:_len(\d+))?_/);
        if (match) {
            return {
                width: parseInt(match[1], 10),
                height: parseInt(match[2], 10),
                channels: parseInt(match[3], 10),
                bitsPerChannel: parseInt(match[4], 10),
                significantLength: match[5] ? parseInt(match[5], 10) : undefined 
            };
        }
        return null;
    }
    function processUploadedImageForIndexing(sourceImageElement, originalFileObject, forcedSystemParamsViaDownscale) {
        let processingWidth = sourceImageElement.width;
        let processingHeight = sourceImageElement.height;
        let processingChannels = appState.imageDecodeParams.channels; 
        let processingBPC = appState.imageDecodeParams.bitsPerChannel;  
        let processingSignificantLength = undefined; 
        let isSystemImageSource = false; 
        let usingRestoredMetadata = false; 
        let parsedParamsToUse = null; 

        if (forcedSystemParamsViaDownscale) { 
            parsedParamsToUse = forcedSystemParamsViaDownscale;
            isSystemImageSource = true; 
            console.log("Processing (possibly downscaled) system image. Using C/BPC/SigLen from original filename.");
        } else if (originalFileObject) { 
            const filenameParams = parseFilenameForSystemImageParams(originalFileObject.name);
            if (filenameParams) { 
                isSystemImageSource = true;
                parsedParamsToUse = filenameParams; 
                if (sourceImageElement.width !== filenameParams.width || sourceImageElement.height !== filenameParams.height) {
                    const proceed = confirm(`System image "${originalFileObject.name}" appears altered. Its dimensions (${sourceImageElement.width}x${sourceImageElement.height}) differ from metadata (${filenameParams.width}x${filenameParams.height}).\n\n- OK: Attempt processing using original encoding parameters (C, BPC, SigLen) with new dimensions. CI will likely change.\n- Cancel: Treat as new/arbitrary image, processed using current UI settings.`);
                    if (!proceed) {
                        parsedParamsToUse = null; 
                        isSystemImageSource = false;
                        console.log("User chose to treat altered system image as arbitrary. Using UI C/BPC.");
                    } else {
                         console.warn(`Processing altered system image. Using C/BPC/SigLen from filename. CI will likely differ.`);
                    }
                } else {
                     console.log("Intact system-generated image: Using metadata from filename:", filenameParams);
                }
            } else {
                console.log("Processing arbitrary image using current UI C/BPC settings.");
            }
        } else { 
            console.log("Processing (likely downscaled arbitrary) image using current UI C/BPC settings.");
        }

        if (parsedParamsToUse) {
            processingChannels = parsedParamsToUse.channels;
            processingBPC = parsedParamsToUse.bitsPerChannel;
            processingSignificantLength = parsedParamsToUse.significantLength; 
            usingRestoredMetadata = true;
        }
        
        const loadingMessageBase = `Processing ${processingWidth}x${processingHeight} image (C:${processingChannels}, BPC:${processingBPC}${processingSignificantLength !== undefined ? ', SigLen:'+processingSignificantLength : ''})`;
        showLoader(`${loadingMessageBase}... 0%`, true);
    
        requestAnimationFrame(() => { 
            try {
                const prepCanvas = document.createElement('canvas');
                const prepCtx = prepCanvas.getContext('2d', { alpha: true }); 
                prepCanvas.width = processingWidth; 
                prepCanvas.height = processingHeight;
                prepCtx.imageSmoothingEnabled = false; 
                prepCtx.drawImage(sourceImageElement, 0, 0, processingWidth, processingHeight);
                const imageDataFromCanvas = prepCtx.getImageData(0, 0, processingWidth, processingHeight);
                
                imageDataToPixelArrayChunked(
                    imageDataFromCanvas,
                    processingChannels,
                    processingBPC,
                    (percentComplete) => { 
                        dom.loadingMessage.textContent = `${loadingMessageBase}... ${percentComplete}%`;
                    },
                    (pixelValuesFromImage) => { 
                        try { 
                            let finalPixelValuesForIndex;
                            if (typeof processingSignificantLength === 'number' && processingSignificantLength <= pixelValuesFromImage.length) {
                                finalPixelValuesForIndex = pixelValuesFromImage.slice(0, processingSignificantLength);
                                if (processingSignificantLength < pixelValuesFromImage.length) {
                                    console.log(`Used significant length ${processingSignificantLength} from filename. Trimmed pixel array from ${pixelValuesFromImage.length}.`);
                                }
                            } else { 
                                finalPixelValuesForIndex = pixelValuesFromImage;
                                if (typeof processingSignificantLength === 'number' && processingSignificantLength > pixelValuesFromImage.length) {
                                    console.warn(`Filename specified significant length ${processingSignificantLength}, but image only yielded ${pixelValuesFromImage.length} pixels. Using all available pixels.`);
                                }
                            }
                            appState.canonicalIndex = imagePixelsToIndex(finalPixelValuesForIndex, processingChannels, processingBPC);
                            appState.sourceOfChange = 'imageUpload';
                            appState.lastDirectInputSequence = null; 
                            if (usingRestoredMetadata) { 
                                appState.imageDecodeParams.channels = processingChannels;
                                appState.imageDecodeParams.bitsPerChannel = processingBPC;
                                dom.imageChannelsSelect.value = processingChannels;
                                dom.imageBpcSelect.value = processingBPC;
                            }
                            updateAllViews(); 
                        } catch (eInner) {
                            console.error("Error after image pixel processing:", eInner);
                            showErrorModal("Image Processing Error", `Error after pixel conversion: ${eInner.message}`);
                            hideLoader(); 
                        }
                    }
                );
            } catch (eOuter) {
                console.error("Error setting up image processing:", eOuter);
                showErrorModal("Image Processing Error", `Setup error: ${eOuter.message}`);
                hideLoader(); 
            }
        });
    }
    function onImageFileSelected(event) {
        const file = event.target.files[0];
        if (!file) { dom.imageUploadInput.value = ''; return; } 
        showLoader("Loading image file...", true);
        const img = new Image();
        const objectURL = URL.createObjectURL(file);
        img.onload = () => {
            URL.revokeObjectURL(objectURL);
            const originalSystemParams = parseFilenameForSystemImageParams(file.name);
            if (img.width > CONFIG.IMAGE_UPLOAD_MAX_SOURCE_DRAW_DIM || img.height > CONFIG.IMAGE_UPLOAD_MAX_SOURCE_DRAW_DIM) {
                const message = originalSystemParams 
                    ? `System image "${file.name}" (${img.width}x${img.height}) is large. Pre-downscaling will alter its data and thus its Canonical Index. However, its original encoding parameters (C, BPC, SigLen) will be used for interpretation. Continue with downscaling?`
                    : `Image is ${img.width}x${img.height}. Pre-downscaling to ~${CONFIG.IMAGE_UPLOAD_MAX_SOURCE_DRAW_DIM}px max dimension will alter data for CI generation (using current UI C/BPC). Continue?`;
                if (confirm(message)) {
                    showLoader("Pre-downscaling large image...", true);
                    const iC = document.createElement('canvas'); const iCtx = iC.getContext('2d'); 
                    iCtx.imageSmoothingEnabled = true; 
                    const scale = Math.min(CONFIG.IMAGE_UPLOAD_MAX_SOURCE_DRAW_DIM / img.width, CONFIG.IMAGE_UPLOAD_MAX_SOURCE_DRAW_DIM / img.height);
                    iC.width = Math.max(1, Math.floor(img.width * scale)); iC.height = Math.max(1, Math.floor(img.height * scale));
                    iCtx.drawImage(img, 0, 0, iC.width, iC.height); 
                    const downscaledImg = new Image();
                    downscaledImg.onload = () => processUploadedImageForIndexing(downscaledImg, file, originalSystemParams); 
                    downscaledImg.onerror = () => { showErrorModal("Image Error", "Failed during pre-downscaling step."); hideLoader(); };
                    downscaledImg.src = iC.toDataURL(); 
                } else { 
                    processUploadedImageForIndexing(img, file, originalSystemParams);
                }
            } else { 
                processUploadedImageForIndexing(img, file, originalSystemParams); 
            }
            dom.imageUploadInput.value = ''; 
        };
        img.onerror = () => { URL.revokeObjectURL(objectURL); showErrorModal("Image Load Error", "Cannot load selected file as an image."); hideLoader(); dom.imageUploadInput.value = ''; };
        img.src = objectURL;
    }
    
    // --- UI Rendering ---
    function renderCanonicalIndex(){if(appState.sourceOfChange!=='indexInput'){dom.canonicalIndexInput.value=appState.canonicalIndex.toString();}}
    function renderText(){if(appState.sourceOfChange!=='textInput'){try{dom.textInput.value=indexToText(appState.canonicalIndex);}catch(e){dom.textInput.value=`Error: ${e.message.substring(0,100)}`;}}}
    function renderMainImage(imageAttributes){
        const{width,height,numPixels}=imageAttributes; 
        dom.mainImageDimensionsDisplay.textContent=`${width}x${height}`;
        dom.mainImageStatus.style.display='none';dom.mainImageCanvas.style.opacity=1;
        
        const container = dom.pixelGridContainer; 
        if (!container) { 
            console.error("Pixel grid container not found for sizing.");
            dom.mainImageCanvas.width=width; 
            dom.mainImageCanvas.height=height;
            dom.mainImageCanvas.style.width = `${width}px`;
            dom.mainImageCanvas.style.height = `${height}px`;
        } else {
            const containerPadding = 20; // Match CSS padding (10px each side)
            const availableWidth = Math.max(0, container.clientWidth - containerPadding); 
            const availableHeight = Math.max(0, container.clientHeight - containerPadding); 

            dom.mainImageCanvas.width=width;  
            dom.mainImageCanvas.height=height;
            
            let displayWidth = width;
            let displayHeight = height;

            if (width > 0 && height > 0 && availableWidth > 0 && availableHeight > 0) {
                const imageAspectRatio = width / height;
                const containerAspectRatio = availableWidth / availableHeight;

                if (imageAspectRatio > containerAspectRatio) {
                    displayWidth = availableWidth;
                    displayHeight = Math.floor(availableWidth / imageAspectRatio);
                } else {
                    displayHeight = availableHeight;
                    displayWidth = Math.floor(availableHeight * imageAspectRatio);
                }
            } else { 
                displayWidth = Math.max(width, 1); 
                displayHeight = Math.max(height, 1);
            }
            displayWidth = Math.max(1, displayWidth); // Ensure at least 1px
            displayHeight = Math.max(1, displayHeight);

            dom.mainImageCanvas.style.width = `${displayWidth}px`;
            dom.mainImageCanvas.style.height = `${displayHeight}px`;
        }
        
        try{
            const effectiveNumPixels = (appState.canonicalIndex === 0n && numPixels === 0 && width === 1 && height === 1) ? 1 : numPixels;
            const pixelValues=indexToImagePixelArray(appState.canonicalIndex,effectiveNumPixels,appState.imageDecodeParams.channels,appState.imageDecodeParams.bitsPerChannel);
            const imageData=pixelArrayToImageData(pixelValues,width,height,appState.imageDecodeParams.channels,appState.imageDecodeParams.bitsPerChannel);
            
            mainImageCtx.clearRect(0,0,width,height); 
            mainImageCtx.putImageData(imageData,0,0);
        }catch(e){
            console.error("Error rendering main image:",e);
            dom.mainImageStatus.textContent=`Error: ${e.message.substring(0,100)}`;
            dom.mainImageStatus.style.display='block';
            if(dom.mainImageCanvas.width > 0 && dom.mainImageCanvas.height > 0) { 
                mainImageCtx.fillStyle="rgba(200,0,0,0.1)";
                mainImageCtx.fillRect(0,0,dom.mainImageCanvas.width,dom.mainImageCanvas.height);
            }
        }
    }
    function renderSequence() {
        let sequenceForTextarea;
        let displayedLength; 
        if (appState.sourceOfChange === 'sequenceInput' || appState.sourceOfChange === 'rawBinaryUpload') {
            sequenceForTextarea = appState.lastDirectInputSequence ? [...appState.lastDirectInputSequence] : [];
            displayedLength = sequenceForTextarea.length;
        } else {
            displayedLength = calculateMinSequenceLength(appState.canonicalIndex);
            try {
                sequenceForTextarea = indexToSequence(appState.canonicalIndex, displayedLength);
            } catch (e) {
                showErrorModal("Sequence Render Error", e.message);
                sequenceForTextarea = [`Error: ${e.message.substring(0,50)}`];
                displayedLength = sequenceForTextarea.length;
            }
        }
        dom.sequenceInput.value = sequenceForTextarea.join(', ');
        dom.sequenceCanonicalLengthDisplay.textContent = displayedLength; 
    }
    
    // --- UI Update & Event Handlers ---
    function updateAllViews(options={}){
        showLoader("Updating views..."); 
        requestAnimationFrame(() => { 
            try {
                renderCanonicalIndex();
                renderText();
                let currentImageAttributes; 
                currentImageAttributes=calculateOptimalImageDimensions(appState.canonicalIndex,appState.imageDecodeParams.channels,appState.imageDecodeParams.bitsPerChannel); 
                renderMainImage(currentImageAttributes);
                renderSequence();
            } catch (e) {
                showErrorModal("View Update Error", `Error during view update: ${e.message}`);
                console.error("Error in updateAllViews:", e);
                if(mainImageCtx && dom.mainImageCanvas) {
                     mainImageCtx.clearRect(0,0,dom.mainImageCanvas.width, dom.mainImageCanvas.height);
                }
                dom.mainImageStatus.textContent="Error updating views.";
                dom.mainImageStatus.style.display='block';
            } finally {
                hideLoader();
            }
        });
    }
    dom.canonicalIndexInput.addEventListener('input',debounce(()=>{const newIndex=safeParseBigInt(dom.canonicalIndexInput.value);if(newIndex!==null&&newIndex!==appState.canonicalIndex){appState.canonicalIndex=newIndex;appState.sourceOfChange='indexInput';appState.lastDirectInputSequence=null;updateAllViews();}else if(newIndex===null&&dom.canonicalIndexInput.value.trim()!==""){showErrorModal("Input Error","Invalid BigInt format in Canonical Index field.");dom.canonicalIndexInput.value=appState.canonicalIndex.toString();}},CONFIG.DEBOUNCE_DELAY_INPUT));
    dom.textInput.addEventListener('input',debounce(()=>{try{const newIndex=textToIndex(dom.textInput.value);if(newIndex!==appState.canonicalIndex){appState.canonicalIndex=newIndex;appState.sourceOfChange='textInput';appState.lastDirectInputSequence=null;updateAllViews();}}catch(e){showErrorModal("Text Encoding Error",e.message);}},CONFIG.DEBOUNCE_DELAY_TEXT_AREA));
    dom.imageUploadInput.addEventListener('change',onImageFileSelected);
    dom.downloadImagePNGButton.addEventListener('click', () => {
        try {
            const currentImageAttributes = calculateOptimalImageDimensions(appState.canonicalIndex, appState.imageDecodeParams.channels, appState.imageDecodeParams.bitsPerChannel);
            const {width, height, numPixels} = currentImageAttributes; 
            // For index 0, numPixels will be 1. Ensure width/height are also 1 for this case.
            const exportWidth = (appState.canonicalIndex === 0n && width === 0) ? 1 : width;
            const exportHeight = (appState.canonicalIndex === 0n && height === 0) ? 1 : height;
            const exportNumPixels = (appState.canonicalIndex === 0n && numPixels === 0) ? 1 : numPixels;

            if (exportWidth === 0 || exportHeight === 0 || (exportNumPixels === 0 && appState.canonicalIndex !== 0n) ) { 
                showErrorModal("Download Error", "Calculated image for CI has zero dimensions or zero significant pixels for non-zero index."); return;
            }
            const pixelValues = indexToImagePixelArray(appState.canonicalIndex, exportNumPixels, appState.imageDecodeParams.channels, appState.imageDecodeParams.bitsPerChannel);
            const pristineImageData = pixelArrayToImageData(pixelValues, exportWidth, exportHeight, appState.imageDecodeParams.channels, appState.imageDecodeParams.bitsPerChannel);
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = exportWidth; tempCanvas.height = exportHeight;
            const tempCtx = tempCanvas.getContext('2d'); tempCtx.putImageData(pristineImageData, 0, 0);
            const dataURL = tempCanvas.toDataURL('image/png'); 
            const link = document.createElement('a');
            const dims = `${exportWidth}x${exportHeight}`; 
            const chans = appState.imageDecodeParams.channels; 
            const bpc = appState.imageDecodeParams.bitsPerChannel;
            const significantLen = exportNumPixels; 
            const ciPart = appState.canonicalIndex.toString().substring(0, 10).replace(/\D/g,'_');
            link.download = `cimg_${dims}_c${chans}b${bpc}_len${significantLen}_idx${ciPart}_${Date.now()}.png`;
            link.href = dataURL; document.body.appendChild(link); link.click(); document.body.removeChild(link);
        } catch (e) { showErrorModal("Download PNG Error", "Could not generate PNG: " + e.message); console.error("PNG Download error:", e); }
    });
    function handleImageDecodeParamsChange(){
        const newChannels = parseInt(dom.imageChannelsSelect.value);
        const newBPC = parseInt(dom.imageBpcSelect.value);
        if (newChannels !== appState.imageDecodeParams.channels || newBPC !== appState.imageDecodeParams.bitsPerChannel) {
            appState.imageDecodeParams.channels=newChannels;
            appState.imageDecodeParams.bitsPerChannel=newBPC;
            appState.sourceOfChange='imageParamsChange';
            appState.lastDirectInputSequence=null; 
            updateAllViews();
        }
    }
    dom.imageChannelsSelect.addEventListener('change',handleImageDecodeParamsChange);
    dom.imageBpcSelect.addEventListener('change',handleImageDecodeParamsChange);
    dom.sequenceInput.addEventListener('input',debounce(()=>{
        const sequenceStr=dom.sequenceInput.value.trim();
        try{
            let parsedSequence=[];
            if(sequenceStr!==""){ 
                parsedSequence=sequenceStr.split(',').map(s=>s.trim()).filter(s=>s!=="").map(sVal=>{
                    const num=Number(sVal);
                    if(isNaN(num)||num<0||num>Number(SEQUENCE_Max_Val_BigInt)){throw new Error(`Invalid sequence value: '${sVal}'. Must be a number between 0 and ${Number(SEQUENCE_Max_Val_BigInt)}.`);}
                    return num;
                });
            }
            appState.lastDirectInputSequence=parsedSequence.slice(); 
            const newIndex=sequenceToIndex(parsedSequence);
            if (newIndex !== appState.canonicalIndex) {
                 appState.canonicalIndex=newIndex;
                 appState.sourceOfChange='sequenceInput';
                 updateAllViews();
            } else { 
                renderSequence(); 
            }
        }catch(e){
            showErrorModal("Sequence Input Error",e.message);
        }
    },CONFIG.DEBOUNCE_DELAY_TEXT_AREA));
    dom.saveSequenceRawBinaryButton.addEventListener('click',saveSequenceAsRawBinary);
    dom.loadSequenceRawBinaryInput.addEventListener('change',(event)=>{const file=event.target.files[0];if(file)loadSequenceFromRawBinary(file); });
    
    // --- Initialization ---
    function initializeApp(){
        showLoader("Initializing Application...",true);
        dom.charSetSizeDisplay.textContent=CHAR_SET_Array.length; 
        dom.imageChannelsSelect.value=appState.imageDecodeParams.channels;
        dom.imageBpcSelect.value=appState.imageDecodeParams.bitsPerChannel;
        appState.canonicalIndex=0n;
        appState.sourceOfChange='initialLoad';
        updateAllViews(); 
        if(appState.canonicalIndex === 0n && appState.sourceOfChange === 'initialLoad'){
             dom.mainImageStatus.textContent="Enter data or upload an image.";
             dom.mainImageStatus.style.display='block';
        }
    }
    window.addEventListener('load',initializeApp);
</script>
</body>
</html>
