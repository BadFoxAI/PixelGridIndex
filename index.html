<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Interconverter (Pure HTML)</title>
</head>
<body>

    <header>
        <h1>Data Interconverter (Pure HTML Core)</h1>
    </header>

    <hr>

    <main>
        <!-- Using a simple table for basic two-column layout -->
        <table>
            <tr>
                <td> <!-- Left Column -->
                    <h2>Canonical Index (BigInt)</h2>
                    <textarea id="canonicalIndexInput" rows="10" cols="70" placeholder="0"></textarea>
                    <br>
                    <small>Input an arbitrary-precision non-negative integer. Non-digits are ignored.</small>
                    <br><br>
                    <button id="saveCanonicalIndexButton">Save Canonical Index to File</button>
                    <br><br>
                    <label for="loadCanonicalIndexInput">Load Canonical Index from File:</label>
                    <input type="file" id="loadCanonicalIndexInput" accept=".txt,text/plain">
                </td>

                <td> <!-- Right Column -->
                    <h2>Numerical Sequence (<span id="sequenceBitDepthDisplay">24</span>-bit elements)</h2>
                    
                    <div>
                        <label for="sequenceBitDepthSelect">View Element Bit Depth:</label>
                        <select id="sequenceBitDepthSelect">
                            <option value="1">1-bit (0 to 1)</option>
                            <option value="2">2-bit (0 to 3)</option>
                            <option value="4">4-bit (0 to 15)</option>
                            <option value="8">8-bit (0 to 255)</option>
                            <option value="12">12-bit (0 to 4,095)</option>
                            <option value="16">16-bit (0 to 65,535)</option>
                            <option value="24" selected>24-bit (0 to 16,777,215)</option>
                            <option value="32">32-bit (0 to 4,294,967,295)</option>
                            <option value="48">48-bit</option>
                            <option value="56">56-bit</option>
                            <option value="64">64-bit</option>
                            <option value="custom">Custom...</option> 
                        </select>
                    </div>

                    <div id="customBitDepthGroupContainer"> <!-- Container for custom input -->
                        <!-- This div will be shown/hidden by JS -->
                    </div>

                    <p>Sequence Output (Read-Only):</p>
                    <textarea id="sequenceOutputDisplay" rows="10" cols="70" readonly placeholder="Sequence appears here..."></textarea>
                    <p>Canonical Length: <span id="sequenceCanonicalLengthDisplay">0</span> elements</p>
                    <button id="copySequenceButton">Copy Sequence to Clipboard</button>
                </td>
            </tr>
        </table>
    </main>

    <hr>
    <div id="errorDisplay"></div> <!-- Errors will appear here as plain text -->
    <div id="loadingOverlay">Loading...</div> <!-- Basic loading text -->

<script type="module">
    import init, { AppState } from './rust-wasm-lib/pkg/data_interconverter_wasm.js';

    const CONFIG = {
        DEFAULT_SEQUENCE_BIT_DEPTH: 24,
        MIN_BIT_DEPTH: 1, 
        MAX_BIT_DEPTH: 256, 
        DEBOUNCE_DELAY_INPUT: 350, 
        LOADER_FLICKER_THRESHOLD: 300, // Though loader is very basic now
    };

    const dom = {
        canonicalIndexInput: document.getElementById('canonicalIndexInput'),
        saveCanonicalIndexButton: document.getElementById('saveCanonicalIndexButton'),
        loadCanonicalIndexInput: document.getElementById('loadCanonicalIndexInput'),
        
        sequenceBitDepthSelect: document.getElementById('sequenceBitDepthSelect'),
        customBitDepthGroupContainer: document.getElementById('customBitDepthGroupContainer'), 
        // customBitDepthInput and applyCustomBitDepthButton will be created dynamically
        sequenceBitDepthDisplay: document.getElementById('sequenceBitDepthDisplay'),
        sequenceOutputDisplay: document.getElementById('sequenceOutputDisplay'), 
        sequenceCanonicalLengthDisplay: document.getElementById('sequenceCanonicalLengthDisplay'),
        copySequenceButton: document.getElementById('copySequenceButton'),
        
        errorDisplay: document.getElementById('errorDisplay'),
        loadingOverlay: document.getElementById('loadingOverlay'),
    };

    // Hide elements initially via JS, as no CSS
    dom.customBitDepthGroupContainer.innerHTML = ''; // Clear it initially
    dom.loadingOverlay.hidden = true;
    dom.errorDisplay.hidden = true;


    let appStateWasm;
    let currentActiveBitDepth = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH;

    function showError(message) {
        dom.errorDisplay.textContent = `ERROR: ${message}`;
        dom.errorDisplay.hidden = false;
        console.error("Application Error:", message);
    }
    function clearError() {
        dom.errorDisplay.textContent = '';
        dom.errorDisplay.hidden = true;
    }

    function showLoader(show) {
        dom.loadingOverlay.hidden = !show;
    }
    function debounce(func, delay) { 
        let timeout; 
        return function (...args) { 
            clearTimeout(timeout); 
            timeout = setTimeout(() => func.apply(this, args), delay); 
        };
    }
    function safeParseBigInt(str) { 
        try { 
            const s = String(str); 
            const numericStr = s.replace(/[^0-9]/g, ''); 
            return numericStr === "" ? 0n : BigInt(numericStr); 
        } catch (e) { return null; } 
    }

    function updateSequenceUIDisplaySettings(bitDepth) {
        dom.sequenceBitDepthDisplay.textContent = bitDepth;
        const maxValBigInt = (2n ** BigInt(bitDepth)) - 1n;
        dom.sequenceOutputDisplay.placeholder = `Sequence of ${bitDepth}-bit numbers (0 to ${maxValBigInt}) appears here.`;
        
        // Update custom input attributes if it exists
        const customInput = document.getElementById('customBitDepthInput');
        if (customInput) {
            customInput.max = CONFIG.MAX_BIT_DEPTH;
        }
        const customLabelSpan = document.getElementById('customBitDepthMinMaxLabel');
        if (customLabelSpan) {
            customLabelSpan.textContent = `${CONFIG.MIN_BIT_DEPTH}-${CONFIG.MAX_BIT_DEPTH}`;
        }
    }
    
    function getValidatedBitDepthFromCustomInput() {
        const customInput = document.getElementById('customBitDepthInput');
        if (!customInput) return currentActiveBitDepth; // Should not happen if UI is built

        let bitDepth = parseInt(customInput.value, 10);
        if (isNaN(bitDepth) || bitDepth < CONFIG.MIN_BIT_DEPTH || bitDepth > CONFIG.MAX_BIT_DEPTH) {
            showError(`Custom bit depth must be ${CONFIG.MIN_BIT_DEPTH}-${CONFIG.MAX_BIT_DEPTH}. Reverting to ${currentActiveBitDepth}.`);
            customInput.value = currentActiveBitDepth;
            return currentActiveBitDepth;
        }
        return bitDepth;
    }

    function createCustomBitDepthUI() {
        dom.customBitDepthGroupContainer.innerHTML = `
            <label for="customBitDepthInput">Custom Bit Depth (<span id="customBitDepthMinMaxLabel">${CONFIG.MIN_BIT_DEPTH}-${CONFIG.MAX_BIT_DEPTH}</span>):</label>
            <input type="number" id="customBitDepthInput" min="${CONFIG.MIN_BIT_DEPTH}" max="${CONFIG.MAX_BIT_DEPTH}" value="${currentActiveBitDepth}" size="5">
            <button id="applyCustomBitDepthButton">Apply</button>
        `;
        // Re-add event listeners for dynamically created elements
        document.getElementById('applyCustomBitDepthButton').addEventListener('click', applyCustomDepthAction);
        document.getElementById('customBitDepthInput').addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('applyCustomBitDepthButton').click();
            }
        });
    }
    
    function applyCustomDepthAction() { // Renamed to avoid conflict if dom element is also named this
        clearError();
        const customDepth = getValidatedBitDepthFromCustomInput();
        let matchedPreset = false;
        for (let option of dom.sequenceBitDepthSelect.options) {
            if (parseInt(option.value, 10) === customDepth) {
                dom.sequenceBitDepthSelect.value = option.value;
                dom.customBitDepthGroupContainer.innerHTML = ''; // Hide by clearing
                matchedPreset = true;
                break;
            }
        }
        if (!matchedPreset) {
            if (dom.sequenceBitDepthSelect.value !== "custom") {
                 dom.sequenceBitDepthSelect.value = "custom";
            }
        }
        handleBitDepthChange(customDepth);
    }


    async function renderCanonicalIndex() {
        try {
            const indexJsBigInt = await appStateWasm.getCanonicalIndex(); 
            dom.canonicalIndexInput.value = indexJsBigInt.toString();
        } catch (e) { showError(`Render Index: ${e.message || e}`); }
    }

    async function renderSequence() {
        dom.sequenceBitDepthDisplay.textContent = currentActiveBitDepth; 
        let sequenceToDisplay; 
        let displayedLength;

        try {
            // console.log(`[renderSequence] Getting sequence. BitDepth: ${currentActiveBitDepth}`);
            displayedLength = await appStateWasm.calculateMinSequenceLength(currentActiveBitDepth);
            // console.log(`[renderSequence] Min length from WASM: ${displayedLength}`);
            sequenceToDisplay = await appStateWasm.getSequenceRepresentation(displayedLength, currentActiveBitDepth);
            // console.log(`[renderSequence] RAW Sequence from WASM:`, sequenceToDisplay);

            if (!Array.isArray(sequenceToDisplay)) {
                console.warn("renderSequence: sequenceToDisplay from WASM was not an array. Defaulting. Was:", sequenceToDisplay);
                throw new Error("WASM did not return a valid sequence array.");
            }
            sequenceToDisplay = sequenceToDisplay.map((item, idx) => {
                if (typeof item === 'bigint') {
                    return item;
                } else {
                    console.warn(`[renderSequence] WASM returned non-BigInt at index ${idx}:`, item, typeof item);
                    throw new Error(`WASM returned invalid data type for sequence element at index ${idx}. Expected BigInt.`);
                }
            });

        } catch (e) {
            showError(`Render Sequence: ${e.message || e}`);
            sequenceToDisplay = []; 
            displayedLength = 0;
            if (e.message && e.message.includes("target sequence length of 0") && displayedLength === 0 ) {
                /* fine for index 0 */
            } else if (displayedLength > 0) { 
                sequenceToDisplay = Array(displayedLength).fill(0n);
            }
        }
        
        const displayText = sequenceToDisplay.map(bi => bi.toString()).join(', '); 
        dom.sequenceOutputDisplay.value = displayText;
        dom.sequenceCanonicalLengthDisplay.textContent = displayedLength;
    }

    async function updateAllViews() {
        showLoader(true);
        clearError(); 
        try {
            await renderCanonicalIndex();
            await renderSequence();
        } catch (e) { showError(`Update All Views: ${e.message || e}`); }
        finally { showLoader(false); }
    }
    
    dom.canonicalIndexInput.addEventListener('input', debounce(async () => {
        clearError();
        const newIndex = safeParseBigInt(dom.canonicalIndexInput.value);
        if (newIndex !== null) {
            try {
                await appStateWasm.setCanonicalIndex(newIndex);     
                updateAllViews();
            } catch (e) { showError(`Set CI from Input: ${e.message || e}`); }
        } else if (dom.canonicalIndexInput.value.trim() !== "") {
            showError("Invalid BigInt in Canonical Index.");
            try { 
              const currentIndex = await appStateWasm.getCanonicalIndex();
              dom.canonicalIndexInput.value = currentIndex.toString();
            } catch(revertError) { dom.canonicalIndexInput.value = "0"; }
        }
    }, CONFIG.DEBOUNCE_DELAY_INPUT));
    
    function handleBitDepthChange(newBitDepth) {
        if (newBitDepth !== currentActiveBitDepth) {
            currentActiveBitDepth = newBitDepth;
            updateSequenceUIDisplaySettings(currentActiveBitDepth);
            updateAllViews(); 
        }
    }

    dom.sequenceBitDepthSelect.addEventListener('change', () => {
        clearError();
        const selectedValue = dom.sequenceBitDepthSelect.value;
        if (selectedValue === "custom") {
            createCustomBitDepthUI(); // Create and show
            const customInput = document.getElementById('customBitDepthInput'); // Get it after creation
            if(customInput) {
                 customInput.value = currentActiveBitDepth;
                 customInput.focus();
            }
        } else {
            dom.customBitDepthGroupContainer.innerHTML = ''; // Hide by clearing
            handleBitDepthChange(parseInt(selectedValue, 10));
        }
    });
    
    dom.copySequenceButton.addEventListener('click', async () => {
        clearError();
        const sequenceString = dom.sequenceOutputDisplay.value;
        if (navigator.clipboard && navigator.clipboard.writeText) {
            try {
                await navigator.clipboard.writeText(sequenceString);
                const originalText = dom.copySequenceButton.textContent;
                dom.copySequenceButton.textContent = 'Copied!';
                setTimeout(() => { dom.copySequenceButton.textContent = 'Copy Sequence to Clipboard'; }, 1500);
            } catch (err) {
                showError('Failed to copy sequence: ' + (err.message || err));
            }
        } else {
            showError('Clipboard API not available in this browser.');
        }
    });
    
    dom.saveCanonicalIndexButton.addEventListener('click', async () => { /* ... (same as previous) ... */ });
    dom.loadCanonicalIndexInput.addEventListener('change', async (event) => { /* ... (same as previous) ... */ });

    async function initializeApp() {
        showLoader(true);
        updateSequenceUIDisplaySettings(CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH);
        const customInput = document.getElementById('customBitDepthInput'); // Check if exists after UI setup
        if(customInput) {
            customInput.min = CONFIG.MIN_BIT_DEPTH;
            customInput.max = CONFIG.MAX_BIT_DEPTH;
        }
        currentActiveBitDepth = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH; 

        try {
            await init(); 
            appStateWasm = new AppState(); 
            await updateAllViews(); 
        } catch (e) {
            showError(`Initialization Error: ${e.message || e.toString()}`);
        } finally { 
             showLoader(false);
        }
    }
    window.addEventListener('load', initializeApp);
</script>

</body>
</html>
