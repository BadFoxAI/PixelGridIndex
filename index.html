<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Core Data Interconverter (Ultra Bare)</title>
</head>
<body>

    <h1>Data Interconverter - Minimal Core</h1>

    <div>
        <h2>Canonical Index (BigInt)</h2>
        <textarea id="canonicalIndexInput" rows="5" cols="80" placeholder="0"></textarea>
    </div>

    <hr>

    <div>
        <h2>Numerical Sequence (24-bit elements)</h2>
        <p>Values must be between 0 and 16,777,215. Comma-separated.</p>
        <textarea id="sequenceInput" rows="5" cols="80" placeholder="e.g., 16711680, 65280, 255"></textarea>
        <p>Canonical Length: <span id="sequenceCanonicalLengthDisplay">0</span> elements</p>
        <button id="saveSequenceRawBinaryButton">Save 24-bit Sequence as Raw Binary</button>
        <br><br>
        <label for="loadSequenceRawBinaryInput">Load 24-bit Sequence from Raw Binary (_N<len>_B24):</label>
        <input type="file" id="loadSequenceRawBinaryInput" accept=".seqbin,.bin">
    </div>

    <hr>

    <div id="errorDisplay" style="color: red; margin-top: 20px; border: 1px solid red; padding: 10px; min-height: 30px;"></div>
    <div id="loadingOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(128,128,128,0.7); color:black; text-align:center; padding-top:40vh; font-size:2em; border: 2px solid black;">Loading...</div>

<script type="module">
    import init, { AppState } from './rust-wasm-lib/pkg/data_interconverter_wasm.js';

    const dom = {
        canonicalIndexInput: document.getElementById('canonicalIndexInput'),
        sequenceInput: document.getElementById('sequenceInput'),
        sequenceCanonicalLengthDisplay: document.getElementById('sequenceCanonicalLengthDisplay'),
        saveSequenceRawBinaryButton: document.getElementById('saveSequenceRawBinaryButton'),
        loadSequenceRawBinaryInput: document.getElementById('loadSequenceRawBinaryInput'),
        errorDisplay: document.getElementById('errorDisplay'),
        loadingOverlay: document.getElementById('loadingOverlay'),
    };

    const FIXED_BIT_DEPTH = 24; // Hardcoded for this reset

    let appStateWasm;
    let sourceOfChange = 'initialLoad';
    let lastDirectInputSequence = null; // Will store array of Numbers

    function showError(message) {
        dom.errorDisplay.textContent = `ERROR: ${message}`;
        // setTimeout(() => { dom.errorDisplay.textContent = ''; }, 7000); // Keep error visible longer
        console.error(message);
    }
    function showLoader(show) {
        dom.loadingOverlay.style.display = show ? 'block' : 'none';
    }
    function debounce(func, delay) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => func(...a), delay); } }

    function safeParseBigInt(str) {
        try {
            const s = String(str);
            const numericStr = s.replace(/[^0-9]/g, '');
            return numericStr === "" ? 0n : BigInt(numericStr);
        } catch (e) { return null; }
    }

    async function renderCanonicalIndex() {
        if (sourceOfChange !== 'indexInput') {
            try {
                const indexJsBigInt = await appStateWasm.getCanonicalIndex();
                dom.canonicalIndexInput.value = indexJsBigInt.toString();
            } catch (e) { showError(`Render Index: ${e.message || e}`); }
        }
    }

    async function renderSequence() {
        let sequenceToDisplay; // Array of Numbers
        let displayedLength;

        if (sourceOfChange === 'sequenceInput' || sourceOfChange === 'rawBinaryUpload') {
            sequenceToDisplay = lastDirectInputSequence ? [...lastDirectInputSequence] : [];
            displayedLength = sequenceToDisplay.length;
        } else {
            try {
                displayedLength = await appStateWasm.calculateMinSequenceLength(); // Rust will use fixed 24-bit
                sequenceToDisplay = await appStateWasm.getSequenceRepresentation(displayedLength); // Rust will use fixed 24-bit
            } catch (e) {
                showError(`Render Sequence: ${e.message || e}`);
                sequenceToDisplay = []; // Default to empty on error
                displayedLength = 0;
                if (e.message && e.message.includes("target sequence length of 0")) {
                    // This is fine for index 0
                } else if (displayedLength > 0) { // If error occurred but length was > 0 from calc
                    sequenceToDisplay = Array(displayedLength).fill(0);
                }
            }
        }
        if (!Array.isArray(sequenceToDisplay)) {
            console.warn("renderSequence: sequenceToDisplay was not an array, defaulting.", sequenceToDisplay);
            sequenceToDisplay = [];
            displayedLength = 0;
        }
        dom.sequenceInput.value = sequenceToDisplay.join(', '); // Simple join
        dom.sequenceCanonicalLengthDisplay.textContent = displayedLength;
    }

    async function updateAllViews() {
        showLoader(true);
        try {
            await renderCanonicalIndex();
            await renderSequence();
        } catch (e) { showError(`Update Views: ${e.message || e}`); }
        finally { showLoader(false); }
    }

    dom.canonicalIndexInput.addEventListener('input', debounce(async () => {
        const newIndex = safeParseBigInt(dom.canonicalIndexInput.value);
        if (newIndex !== null) {
            try {
                await appStateWasm.setCanonicalIndex(newIndex);
                sourceOfChange = 'indexInput';
                lastDirectInputSequence = null;
                updateAllViews();
            } catch (e) { showError(`Set Index from Input: ${e.message || e}`); }
        } else if (dom.canonicalIndexInput.value.trim() !== "") {
            showError("Invalid BigInt in Canonical Index field.");
            try { dom.canonicalIndexInput.value = (await appStateWasm.getCanonicalIndex()).toString(); } catch(e) {/*ignore*/}
        }
    }, 350));

    dom.sequenceInput.addEventListener('input', debounce(async () => {
        const sequenceStr = dom.sequenceInput.value.trim();
        const maxVal = (2**FIXED_BIT_DEPTH) - 1;
        try {
            let parsedSequence = []; // Array of Numbers
            if (sequenceStr !== "") {
                const parts = sequenceStr.split(',');
                parsedSequence = parts.map((sValRaw, idx) => {
                    const sVal = sValRaw.trim();
                    if (sVal === "") return null; // Mark for filtering
                    const num = Number(sVal); // Parse as Number
                    if (isNaN(num) || num < 0 || num > maxVal || !Number.isInteger(num)) {
                        throw new Error(`Invalid sequence value: '${sValRaw}'. Must be an integer between 0 and ${maxVal}.`);
                    }
                    return num;
                }).filter(val => val !== null);
            }
            lastDirectInputSequence = parsedSequence.slice();
            await appStateWasm.setSequenceData(parsedSequence); // Rust expects Vec<u32>
            sourceOfChange = 'sequenceInput';
            updateAllViews();
        } catch (e) { showError(`Set Sequence from Input: ${e.message || e}`); }
    }, 400));

    dom.saveSequenceRawBinaryButton.addEventListener('click', async () => {
        showLoader(true);
        try {
            const currentMinLength = await appStateWasm.calculateMinSequenceLength();
            const sequenceToSave = await appStateWasm.getSequenceRepresentation(currentMinLength); // Array of Numbers

            const currentCanonicalIndex = await appStateWasm.getCanonicalIndex();
            if ((!sequenceToSave || sequenceToSave.length === 0) && currentCanonicalIndex !== 0n) {
                showError("Save Error: Cannot save empty sequence for a non-zero index."); 
                showLoader(false); return;
            }
            
            const numElements = sequenceToSave.length;
            const bytesPerElement = Math.ceil(FIXED_BIT_DEPTH / 8); // Should be 3 for 24-bit
            
            await new Promise(resolve => setTimeout(resolve, 10)); 

            const buffer = new ArrayBuffer(numElements * bytesPerElement);
            const dataView = new DataView(buffer);
            let offset = 0;
            for (const val of sequenceToSave) { // val is a Number
                if (val < 0 || val > ((2**FIXED_BIT_DEPTH)-1) ) { throw new Error(`Sequence value ${val} out of range for saving.`);}
                // Write 3 bytes for 24-bit number (MSB first)
                dataView.setUint8(offset++, (val >> 16) & 0xFF);
                dataView.setUint8(offset++, (val >> 8) & 0xFF);
                dataView.setUint8(offset++, val & 0xFF);
            }
            
            const blob = new Blob([buffer], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.download = `sequence_N${numElements}_B${FIXED_BIT_DEPTH}_${Date.now()}.seqbin`;
            link.href = URL.createObjectURL(blob); document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href);
        } catch (e) { showError(`Save Binary Error: ${e.message || e}`); console.error(e); } 
        finally { showLoader(false); }
    });

    dom.loadSequenceRawBinaryInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        showLoader(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                await new Promise(resolve => setTimeout(resolve, 10)); 
                const arrayBuffer = e.target.result;
                if (!(arrayBuffer instanceof ArrayBuffer)) { throw new Error("File content not ArrayBuffer."); }

                let expectedN = -1; let expectedB_fromFile = -1;
                const matchN = file.name.match(/_N(\d+)_/); 
                const matchB = file.name.match(/_B(\d+)_/);
                if (matchN && matchN[1]) expectedN = parseInt(matchN[1], 10);
                if (matchB && matchB[1]) expectedB_fromFile = parseInt(matchB[1], 10);

                if (isNaN(expectedN) || expectedN < 0) { throw new Error("Filename metadata for N is missing/invalid."); }
                if (isNaN(expectedB_fromFile) || expectedB_fromFile !== FIXED_BIT_DEPTH) {
                    throw new Error(`Filename metadata for B is invalid or doesn't match expected ${FIXED_BIT_DEPTH}-bit. Got: ${expectedB_fromFile}`);
                }
                                
                const bytesPerElement = Math.ceil(FIXED_BIT_DEPTH / 8); // Should be 3
                if (arrayBuffer.byteLength === 0 && expectedN === 0) { /* fine */ }
                else if (arrayBuffer.byteLength % bytesPerElement !== 0) {
                     showError(`Load Warning: File size (${arrayBuffer.byteLength} bytes) is not a multiple of ${bytesPerElement} bytes for ${FIXED_BIT_DEPTH}-bit elements.`);
                }
                const numPossibleElements = Math.floor(arrayBuffer.byteLength / bytesPerElement);
                if (numPossibleElements < expectedN && expectedN > 0) {
                     showError(`Load Warning: File contains data for only ${numPossibleElements} elements, but filename expected N=${expectedN}. Processing available.`);
                }
                
                const dataView = new DataView(arrayBuffer);
                const loadedSeq = []; // Array of Numbers
                const numElementsToRead = Math.min(expectedN, numPossibleElements);

                for (let i = 0; i < numElementsToRead; i++) {
                    const offset = i * bytesPerElement;
                    // Read 3 bytes for 24-bit number (MSB first)
                    const val = (dataView.getUint8(offset) << 16) | 
                                (dataView.getUint8(offset + 1) << 8) | 
                                dataView.getUint8(offset + 2);
                    loadedSeq.push(val);
                }
                
                lastDirectInputSequence = loadedSeq.slice(); 
                await appStateWasm.setSequenceData(loadedSeq); // Rust expects Vec<u32>
                sourceOfChange = 'rawBinaryUpload';
                updateAllViews();
            } catch (e) { showError(`Load Binary Error: ${e.message || e}`); console.error(e); } 
            finally { showLoader(false); dom.loadSequenceRawBinaryInput.value = ''; }
        };
        reader.onerror = () => { showError("File Read Error: Could not read selected binary file."); showLoader(false); dom.loadSequenceRawBinaryInput.value = ''; };
        reader.readAsArrayBuffer(file);
    });

    async function initializeApp() {
        showLoader(true);
        try {
            await init(); 
            appStateWasm = new AppState(); 
            sourceOfChange = 'initialLoad';
            await updateAllViews(); 
        } catch (e) {
            showError(`Initialization Error: ${e.message || e.toString()}`);
        } finally { 
             showLoader(false);
        }
    }
    window.addEventListener('load', initializeApp);
</script>

</body>
</html>
