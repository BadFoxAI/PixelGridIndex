<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Data Interconverter (Core)</title>
  <style>
    :root { /* CSS Variables */
      --primary-bg: #f4f6f8; --secondary-bg: #ffffff; --text-color: #2c3e50; --label-color: #5a6573;
      --input-border: #ced4da; --input-focus-border: #007bff; --accent-color: #007bff;
      --accent-hover-color: #0056b3; --danger-color: #e74c3c; --shadow-color: rgba(0,0,0,0.06);
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      --monospace-font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
      --container-max-width: 1200px;
      --controls-max-width: 430px; --border-radius: 5px;
    }
    html, body { height:100%; margin:0; }
    body { font-family:var(--font-family); background-color:var(--primary-bg); color:var(--text-color); display:flex; flex-direction:column; font-size:15px; line-height:1.65; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    .container { display:flex; flex-direction:column; flex-grow:1; max-width:var(--container-max-width); margin:0 auto; width:100%; }
    header { background:var(--accent-color); color:white; padding:12px 20px; text-align:center; box-shadow:0 2px 3px var(--shadow-color); flex-shrink:0; }
    header h1 { margin:0; font-size:1.5em; font-weight:500; }
    main { display:flex; flex-grow:1; padding:15px; gap:15px; }
    .panel { background-color:var(--secondary-bg); padding:20px; border-radius:var(--border-radius); box-shadow:0 1px 2px var(--shadow-color); display:flex; flex-direction:column; gap:15px; overflow-y:auto; scrollbar-width:thin; scrollbar-color:var(--input-border) var(--secondary-bg); }
    .panel::-webkit-scrollbar { width:8px; } .panel::-webkit-scrollbar-track { background:var(--secondary-bg); } .panel::-webkit-scrollbar-thumb { background-color:var(--input-border); border-radius:4px; border:2px solid var(--secondary-bg); }
    
    .controls-section { flex:1 1 45%; min-width:300px; }
    .sequence-panel { flex:1 1 55%; min-width:300px; }

    @media (max-width:992px) { 
        main { 
            flex-direction:column; 
            overflow-y:auto; 
            height:auto; 
        }
        .controls-section { order: 1; } 
        .sequence-panel { order: 2; }
    }
    @media (max-width:768px) { 
      .container{padding:0;} 
      header{border-radius:0;} 
    }

    h2, h3 { margin-top:0; color:var(--accent-hover-color); border-bottom:1px solid #e8e8e8; padding-bottom:8px; font-size:1.25em; font-weight:500; }
    h3 { font-size: 1.1em; margin-bottom: 10px; }
    .control-group label { margin-bottom:5px; font-weight:500; color:var(--label-color); font-size:0.9em; }
    .control-group input[type="text"], .control-group input[type="number"], .control-group input[type="file"], .control-group textarea, .control-group select, .control-group button { padding:9px 10px; font-size:0.9em; border-radius:calc(var(--border-radius) - 1px); border:1px solid var(--input-border); box-sizing:border-box; width:100%; }
    .control-group button { background-color:var(--accent-color); color:white; cursor:pointer; transition:background-color 0.2s ease; }
    .control-group button:hover:not(:disabled) { background-color:var(--accent-hover-color); } .control-group button:disabled { background-color:#ccc; cursor:not-allowed; }
    .control-group input[type="text"]:focus, .control-group input[type="number"]:focus, .control-group textarea:focus, .control-group select:focus { border-color:var(--input-focus-border); outline:none; box-shadow:0 0 0 0.15rem rgba(0,123,255,0.2); }
    .control-group textarea { min-height:100px; resize:vertical; font-family:var(--monospace-font-family); white-space:pre-wrap; }
    .control-group small { font-size:0.75em; color:#888; margin-top:5px; display:block; }
    #sequencePanelInfo { font-size: 0.85em; color: #666; margin-top: 10px;}
    .inline-input-group { display: flex; gap: 10px; align-items: center; }
    .inline-input-group input[type="number"] { flex-grow: 1; }
    .inline-input-group button { flex-shrink: 0; width: auto; padding: 9px 15px;}

    .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.45); justify-content:center; align-items:center; }
    .modal-content { background-color:#fefefe; margin:auto; padding:25px; border:1px solid #bbb; width:90%; max-width:420px; border-radius:var(--border-radius); text-align:center; box-shadow:0 4px 15px rgba(0,0,0,0.2); }
    .modal-content h3 { margin-top:0; margin-bottom:12px; font-size:1.2em; color:var(--accent-hover-color); } .modal-content p { font-size:0.95em; margin-bottom:20px; line-height:1.5; }
    .modal-buttons button { margin-top:10px; padding:9px 18px; background-color:var(--accent-color); color:white; border:none; border-radius:calc(var(--border-radius) - 1px); cursor:pointer; font-size:0.9em; transition:background-color 0.2s ease;}
    .modal-buttons button:hover { background-color:var(--accent-hover-color); }
    #loadingOverlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.65); z-index:2000; justify-content:center; align-items:center; flex-direction:column; color:white; font-size:1.2em; text-align:center; }
    #loadingOverlay .spinner { border:8px solid #f3f3f3; border-top:8px solid var(--accent-color); border-radius:50%; width:60px; height:60px; animation:spin 1s linear infinite; margin-top:20px; }
    @keyframes spin { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
  </style>
</head>
<body>
  <div class="container">
    <header><h1>Data Interconverter (Core)</h1></header>
    <main>
      <section class="panel controls-section">
        <h2>Input & Controls</h2>
        <div class="control-group"> <label for="canonicalIndexInput">Canonical Index (BigInt):</label> <textarea id="canonicalIndexInput" rows="3" placeholder="0"></textarea> <small>Arbitrary-precision non-negative integer. Non-digits are ignored.</small> </div>
        <div class="control-group"> <label for="textInput">Text Data:</label> <textarea id="textInput" placeholder="Enter text..."></textarea> <small>Uses a programmer-focused character set (<span id="charSetSizeDisplay">0</span> chars).</small> </div>
      </section>

      <section class="panel sequence-panel">
        <h2>Numerical Sequence (<span id="sequenceBitDepthDisplay">24</span>-bit elements)</h2>
        
        <div class="control-group">
            <label for="sequenceBitDepthSelect">Preset Element Bit Depth:</label>
            <select id="sequenceBitDepthSelect">
                <option value="1">1-bit (0 to 1)</option>
                <option value="2">2-bit (0 to 3)</option>
                <option value="4">4-bit (0 to 15)</option>
                <option value="8">8-bit (0 to 255)</option>
                <option value="12">12-bit (0 to 4,095)</option>
                <option value="16">16-bit (0 to 65,535)</option>
                <option value="24" selected>24-bit (0 to 16,777,215)</option>
                <option value="32">32-bit (0 to 4,294,967,295)</option>
                <option value="48">48-bit</option>
                <option value="56">56-bit</option>
                <option value="64">64-bit</option>
                <option value="custom">Custom...</option> 
            </select>
        </div>

        <div class="control-group" id="customBitDepthGroup" style="display: none;">
            <label for="customBitDepthInput">Custom Element Bit Depth (<span id="customBitDepthMinMaxLabel">1-256</span>):</label>
            <div class="inline-input-group">
                <input type="number" id="customBitDepthInput" min="1" max="256" value="24">
                <button id="applyCustomBitDepthButton">Apply</button>
            </div>
        </div>

        <div class="control-group">
            <label for="sequenceInput">Sequence (Input / Canonical Output):</label>
            <textarea id="sequenceInput" placeholder="e.g., ..."></textarea>
            <small>Comma-separated BigInt values. Reflects CI as sequence of numbers with selected bit depth.</small>
        </div>
        <div id="sequencePanelInfo">Canonical Length: <span id="sequenceCanonicalLengthDisplay">0</span> elements</div>
        
        <div class="control-group" style="margin-top: auto;">
             <button id="saveSequenceRawBinaryButton">Save Sequence as Raw Binary</button>
        </div>
        <div class="control-group">
            <label for="loadSequenceRawBinaryInput">Load Sequence from Raw Binary:</label>
            <input type="file" id="loadSequenceRawBinaryInput" accept=".seqbin,.bin,.dat,application/octet-stream">
            <small>Filename should contain _N<length>_B<bit_depth> metadata (e.g., _B24).</small>
        </div>
      </section>
    </main>
    <footer> <p>Data Interconverter (Core)</p> </footer>
  </div>
  <div class="modal" id="errorModalElement"> <div class="modal-content"> <h3 id="errorModalTitleElement">Notification</h3> <p id="errorModalMessageElement"></p> <div class="modal-buttons"> <button id="errorModalOkButtonElement">OK</button> </div> </div> </div>
  <div id="loadingOverlay"> <p id="loadingMessage">Processing...</p> <div class="spinner"></div> </div>

<script type="module">
    import init, { AppState } from './rust-wasm-lib/pkg/data_interconverter_wasm.js';

    const CONFIG = {
        CHAR_SET_STRING: " \n\t\r" + "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "0123456789" + "!\"#$%&'()*+,-./:;<=>?@" + "[\\]^_`{|}~" + "←↑→↓↔" + "∑√≈≠≤≥÷±∞" + "€₹₽£¥₩" + "¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿" + "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß" + "àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        DEFAULT_SEQUENCE_BIT_DEPTH: 24,
        MIN_BIT_DEPTH: 1, 
        MAX_BIT_DEPTH: 256, // Max bit depth for individual sequence elements
        DEBOUNCE_DELAY_INPUT: 350, DEBOUNCE_DELAY_TEXT_AREA: 400, LOADER_FLICKER_THRESHOLD: 300,
    };
    const CHAR_SET_Array = Array.from(new Set(CONFIG.CHAR_SET_STRING.split(''))).sort();

    const dom = {
        canonicalIndexInput: document.getElementById('canonicalIndexInput'),
        textInput: document.getElementById('textInput'),
        charSetSizeDisplay: document.getElementById('charSetSizeDisplay'),
        sequenceBitDepthSelect: document.getElementById('sequenceBitDepthSelect'),
        customBitDepthGroup: document.getElementById('customBitDepthGroup'), 
        customBitDepthInput: document.getElementById('customBitDepthInput'), 
        applyCustomBitDepthButton: document.getElementById('applyCustomBitDepthButton'),
        customBitDepthMinMaxLabel: document.getElementById('customBitDepthMinMaxLabel'),
        sequenceBitDepthDisplay: document.getElementById('sequenceBitDepthDisplay'),
        sequenceInput: document.getElementById('sequenceInput'),
        sequenceCanonicalLengthDisplay: document.getElementById('sequenceCanonicalLengthDisplay'),
        saveSequenceRawBinaryButton: document.getElementById('saveSequenceRawBinaryButton'),
        loadSequenceRawBinaryInput: document.getElementById('loadSequenceRawBinaryInput'),
        errorModal: { el: document.getElementById('errorModalElement'), title: document.getElementById('errorModalTitleElement'), message: document.getElementById('errorModalMessageElement'), okButton: document.getElementById('errorModalOkButtonElement') },
        loadingOverlay: document.getElementById('loadingOverlay'),
        loadingMessage: document.getElementById('loadingMessage'),
    };

    let appStateWasm;
    let sourceOfChange = 'initialLoad';
    let lastDirectInputSequence = null; 
    let currentActiveBitDepth = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH;

    function showErrorModal(title, message) { dom.errorModal.title.textContent = title; dom.errorModal.message.textContent = message; dom.errorModal.el.style.display = 'flex'; }
    dom.errorModal.okButton.onclick = () => { dom.errorModal.el.style.display = 'none'; };
    window.addEventListener('click', (event) => { if (event.target === dom.errorModal.el) dom.errorModal.el.style.display = 'none'; });
    function debounce(func, delay) { let timeout; return function (...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; }
    let generalUpdateLoaderTimeoutId = null;
    function showLoader(message = "Processing...", forceImmediate = false) { clearTimeout(generalUpdateLoaderTimeoutId); if (forceImmediate) { dom.loadingMessage.textContent = message; dom.loadingOverlay.style.display = 'flex'; } else { generalUpdateLoaderTimeoutId = setTimeout(() => { dom.loadingMessage.textContent = message; dom.loadingOverlay.style.display = 'flex'; }, CONFIG.LOADER_FLICKER_THRESHOLD); } }
    function hideLoader() { clearTimeout(generalUpdateLoaderTimeoutId); dom.loadingOverlay.style.display = 'none'; }
    function safeParseBigInt(str) { try { if (typeof str !== 'string') str = String(str); const numericStr = str.replace(/[^0-9]/g, ''); return numericStr === "" ? 0n : BigInt(numericStr); } catch (e) { return null; } }

    function updateSequenceInputPlaceholderAndTitle(bitDepth) {
        dom.sequenceBitDepthDisplay.textContent = bitDepth;
        const maxValBigInt = (2n ** BigInt(bitDepth)) - 1n;
        dom.sequenceInput.placeholder = `e.g., ${maxValBigInt}, ${maxValBigInt > 0n ? maxValBigInt / 2n : 0n}, ... (0 to ${maxValBigInt})`;
        dom.customBitDepthInput.max = CONFIG.MAX_BIT_DEPTH; 
        dom.customBitDepthMinMaxLabel.textContent = `${CONFIG.MIN_BIT_DEPTH}-${CONFIG.MAX_BIT_DEPTH}`;
    }
    
    function getValidatedBitDepth() {
        let bitDepth = parseInt(dom.customBitDepthInput.value, 10);
        if (isNaN(bitDepth) || bitDepth < CONFIG.MIN_BIT_DEPTH || bitDepth > CONFIG.MAX_BIT_DEPTH) {
            showErrorModal("Invalid Bit Depth", `Custom bit depth must be a number between ${CONFIG.MIN_BIT_DEPTH} and ${CONFIG.MAX_BIT_DEPTH}. Reverting to previous valid depth: ${currentActiveBitDepth}.`);
            dom.customBitDepthInput.value = currentActiveBitDepth;
            return currentActiveBitDepth;
        }
        return bitDepth;
    }

    async function renderCanonicalIndex() {
        if (sourceOfChange !== 'indexInput') {
            try {
                const indexJsBigInt = await appStateWasm.getCanonicalIndex(); 
                dom.canonicalIndexInput.value = indexJsBigInt.toString();
            } catch (e) { console.error("Error getCI:", e); dom.canonicalIndexInput.value = 'Error';}
        }
    }
    async function renderText() {
        if (sourceOfChange !== 'textInput') {
            try {
                const text = await appStateWasm.getTextRepresentation();
                dom.textInput.value = text;
            } catch (e) { dom.textInput.value = `Error: ${e.message.substring(0, 100)}`;}
        }
    }

    async function renderSequence() {
        dom.sequenceBitDepthDisplay.textContent = currentActiveBitDepth; 
        let sequenceForTextarea; 
        let displayedLength;
        // console.log(`[renderSequence] Source: ${sourceOfChange}, BitDepth: ${currentActiveBitDepth}`);

        if (sourceOfChange === 'sequenceInput' || sourceOfChange === 'rawBinaryUpload') {
            sequenceForTextarea = lastDirectInputSequence ? [...lastDirectInputSequence] : []; 
            displayedLength = sequenceForTextarea.length;
            // console.log('[renderSequence] Using lastDirectInputSequence:', sequenceForTextarea.map(b => b.toString()));
        } else {
            try {
                // console.log('[renderSequence] Calling appStateWasm.calculateMinSequenceLength with bit_depth:', currentActiveBitDepth);
                displayedLength = await appStateWasm.calculateMinSequenceLength(currentActiveBitDepth);
                // console.log('[renderSequence] Min length from WASM:', displayedLength);

                // console.log('[renderSequence] Calling appStateWasm.getSequenceRepresentation with length:', displayedLength, 'bit_depth:', currentActiveBitDepth);
                sequenceForTextarea = await appStateWasm.getSequenceRepresentation(displayedLength, currentActiveBitDepth);
                // console.log('[renderSequence] Sequence from WASM (Array<BigInt>):', sequenceForTextarea.map(b => b.toString()));
            } catch (e) {
                showErrorModal("Sequence Render Error", e.message);
                sequenceForTextarea = [0n]; 
                displayedLength = sequenceForTextarea.length; 
                console.error("[renderSequence] Error getting sequence from WASM:", e);
            }
        }
        const displayText = sequenceForTextarea.map(bi => bi.toString()).join(', ');
        // console.log('[renderSequence] Setting textarea value to:', displayText);
        dom.sequenceInput.value = displayText;
        dom.sequenceCanonicalLengthDisplay.textContent = displayedLength;
    }

    async function updateAllViews() {
        showLoader("Updating views...");
        try {
            await renderCanonicalIndex();
            await renderText();
            await renderSequence();
        } catch (e) {
            showErrorModal("View Update Error", `Error: ${e.message}`);
            console.error("Error updateAllViews:", e);
        } finally {
            hideLoader();
        }
    }
    
    dom.canonicalIndexInput.addEventListener('input', debounce(async () => {
        const newIndex = safeParseBigInt(dom.canonicalIndexInput.value);
        if (newIndex !== null) {
            try {
                await appStateWasm.setCanonicalIndex(newIndex);
                sourceOfChange = 'indexInput';
                lastDirectInputSequence = null;
                updateAllViews();
            } catch (e) { showErrorModal("Input Error", `Set CI: ${e.message}`); }
        } else if (dom.canonicalIndexInput.value.trim() !== "") {
            showErrorModal("Input Error", "Invalid BigInt in Canonical Index.");
            try { 
              dom.canonicalIndexInput.value = (await appStateWasm.getCanonicalIndex()).toString();
            } catch(e) { dom.canonicalIndexInput.value = "Error"; }
        }
    }, CONFIG.DEBOUNCE_DELAY_INPUT));

    dom.textInput.addEventListener('input', debounce(async () => {
        try {
            await appStateWasm.setTextData(dom.textInput.value);
            sourceOfChange = 'textInput';
            lastDirectInputSequence = null;
            updateAllViews();
        } catch (e) { showErrorModal("Text Encoding Error", e.message); }
    }, CONFIG.DEBOUNCE_DELAY_TEXT_AREA));
    
    function handleBitDepthChange(newBitDepth) {
        if (newBitDepth !== currentActiveBitDepth) {
            currentActiveBitDepth = newBitDepth;
            sourceOfChange = 'bitDepthChange';
            lastDirectInputSequence = null;
            updateSequenceInputPlaceholderAndTitle(currentActiveBitDepth);
            updateAllViews();
        }
    }

    dom.sequenceBitDepthSelect.addEventListener('change', () => {
        const selectedValue = dom.sequenceBitDepthSelect.value;
        if (selectedValue === "custom") {
            dom.customBitDepthGroup.style.display = 'block';
            dom.customBitDepthInput.value = currentActiveBitDepth;
            dom.customBitDepthInput.focus();
        } else {
            dom.customBitDepthGroup.style.display = 'none';
            handleBitDepthChange(parseInt(selectedValue, 10));
        }
    });

    dom.applyCustomBitDepthButton.addEventListener('click', () => {
        const customDepth = getValidatedBitDepth();
        let matchedPreset = false;
        for (let option of dom.sequenceBitDepthSelect.options) {
            if (parseInt(option.value, 10) === customDepth) {
                dom.sequenceBitDepthSelect.value = option.value;
                dom.customBitDepthGroup.style.display = 'none';
                matchedPreset = true;
                break;
            }
        }
        if (!matchedPreset) {
            if (dom.sequenceBitDepthSelect.value !== "custom") {
                 dom.sequenceBitDepthSelect.value = "custom";
            }
        }
        handleBitDepthChange(customDepth);
    });

     dom.customBitDepthInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            event.preventDefault();
            dom.applyCustomBitDepthButton.click();
        }
    });

    dom.sequenceInput.addEventListener('input', debounce(async () => {
        const sequenceStr = dom.sequenceInput.value.trim();
        const maxValBigInt = (2n ** BigInt(currentActiveBitDepth)) - 1n;
        // console.log(`[Sequence Input] Raw string: "${sequenceStr}", BitDepth: ${currentActiveBitDepth}, MaxVal: ${maxValBigInt}`);

        try {
            let parsedSequence = [];
            if (sequenceStr !== "") {
                parsedSequence = sequenceStr.split(',').map(s => s.trim()).filter(s => s !== "").map((sVal, idx) => {
                    try {
                        const cleanedSval = sVal.replace(/[^0-9]/g, '');
                        if (cleanedSval === '') throw new Error(`Empty value found in sequence after cleaning non-digits from '${sVal}' at element ${idx}.`);
                        const numBigInt = BigInt(cleanedSval);
                        // console.log(`[Sequence Input] Parsing el ${idx}: "${sVal}" -> cleaned "${cleanedSval}" -> BigInt: ${numBigInt}`);
                        if (numBigInt < 0n || numBigInt > maxValBigInt) {
                            throw new Error(`Value '${sVal}' (parsed as ${numBigInt}) is out of range 0 to ${maxValBigInt} for ${currentActiveBitDepth}-bit elements.`);
                        }
                        return numBigInt;
                    } catch (parseError) {
                         // console.error(`[Sequence Input] Error parsing element ${idx}: "${sVal}"`, parseError);
                         throw new Error(parseError.message || `Invalid sequence value: '${sVal}'. Must be a number between 0 and ${maxValBigInt}.`);
                    }
                });
            }
            // console.log('[Sequence Input] Parsed sequence (Array<BigInt>):', parsedSequence.map(b => b.toString()));
            
            lastDirectInputSequence = parsedSequence.slice(); 
            
            // console.log('[Sequence Input] Calling appStateWasm.setSequenceData with bit_depth:', currentActiveBitDepth);
            await appStateWasm.setSequenceData(parsedSequence, currentActiveBitDepth);
            // console.log('[Sequence Input] appStateWasm.setSequenceData successful.');

            sourceOfChange = 'sequenceInput';
            updateAllViews();
        } catch (e) {
            showErrorModal("Sequence Input Error", e.message);
            // console.error('[Sequence Input] Overall error:', e);
        }
    }, CONFIG.DEBOUNCE_DELAY_TEXT_AREA));

    dom.saveSequenceRawBinaryButton.addEventListener('click', async () => {
        try {
            const currentMinLength = await appStateWasm.calculateMinSequenceLength(currentActiveBitDepth);
            const sequenceToSave = await appStateWasm.getSequenceRepresentation(currentMinLength, currentActiveBitDepth);

            const currentCanonicalIndex = await appStateWasm.getCanonicalIndex();
            if ((!sequenceToSave || sequenceToSave.length === 0) && currentCanonicalIndex !== 0n) {
                showErrorModal("Save Error", "Cannot save empty sequence for a non-zero index."); return;
            }
            
            const numElements = sequenceToSave.length;
            const totalBits = BigInt(numElements) * BigInt(currentActiveBitDepth); // Use BigInt for potentially large totalBits
            const totalBytes = Number((totalBits + 7n) / 8n) ; // Equivalent to Math.ceil(totalBits / 8) using BigInt

            showLoader("Generating Raw Binary File...", true);
            await new Promise(resolve => setTimeout(resolve, 10)); 

            const buffer = new ArrayBuffer(totalBytes);
            const byteArray = new Uint8Array(buffer);
            let bitBuffer = 0n;    
            let bitBufferLen = 0;  
            let byteIndex = 0;     

            for (const valBigInt of sequenceToSave) { 
                const elementMask = (1n << BigInt(currentActiveBitDepth)) - 1n;
                const maskedVal = valBigInt & elementMask;

                if (currentActiveBitDepth > 0) { 
                    bitBuffer = (bitBuffer << BigInt(currentActiveBitDepth)) | maskedVal;
                }
                bitBufferLen += currentActiveBitDepth;

                while (bitBufferLen >= 8) {
                    bitBufferLen -= 8;
                    const byteToWrite = (bitBuffer >> BigInt(bitBufferLen)) & 0xFFn; 
                    byteArray[byteIndex++] = Number(byteToWrite); 
                }
            }
            if (bitBufferLen > 0) {
                const remainingBitsMask = (1n << BigInt(bitBufferLen)) - 1n;
                const byteToWrite = (bitBuffer & remainingBitsMask) << BigInt(8 - bitBufferLen); 
                byteArray[byteIndex++] = Number(byteToWrite & 0xFFn);
            }
            
            const finalBlobBuffer = buffer.slice(0, byteIndex); 
            const blob = new Blob([finalBlobBuffer], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.download = `sequence_N${numElements}_B${currentActiveBitDepth}_${Date.now()}.seqbin`;
            link.href = URL.createObjectURL(blob); document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href);
        } catch (e) { 
            showErrorModal("Save Binary Error", e.message); console.error("Save Binary Error:", e); 
        } finally { 
            hideLoader(); 
        }
    });

    dom.loadSequenceRawBinaryInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        showLoader("Loading Raw Binary File...", true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            showLoader("Processing Binary Data...", true);
            try {
                await new Promise(resolve => setTimeout(resolve, 10)); 
                const arrayBuffer = e.target.result;
                if (!(arrayBuffer instanceof ArrayBuffer)) { throw new Error("File content not ArrayBuffer."); }

                let expectedN = -1; let expectedB_fromFile = -1;
                const matchN = file.name.match(/_N(\d+)_/); 
                const matchB = file.name.match(/_B(\d+)_/);
                if (matchN && matchN[1]) expectedN = parseInt(matchN[1], 10);
                if (matchB && matchB[1]) expectedB_fromFile = parseInt(matchB[1], 10);

                if (isNaN(expectedN) || expectedN < 0) { throw new Error("Filename metadata for N is missing/invalid."); }
                if (isNaN(expectedB_fromFile) || expectedB_fromFile < CONFIG.MIN_BIT_DEPTH || expectedB_fromFile > CONFIG.MAX_BIT_DEPTH) {
                    throw new Error(`Filename metadata for B is invalid. Supported: ${CONFIG.MIN_BIT_DEPTH}-${CONFIG.MAX_BIT_DEPTH}. Got: ${expectedB_fromFile}`);
                }
                
                currentActiveBitDepth = expectedB_fromFile;
                dom.sequenceBitDepthSelect.value = Array.from(dom.sequenceBitDepthSelect.options).some(o => parseInt(o.value) === currentActiveBitDepth) ? currentActiveBitDepth.toString() : "custom";

                if (dom.sequenceBitDepthSelect.value === "custom") {
                    dom.customBitDepthGroup.style.display = 'block';
                    dom.customBitDepthInput.value = currentActiveBitDepth;
                } else {
                    dom.customBitDepthGroup.style.display = 'none';
                }
                updateSequenceInputPlaceholderAndTitle(currentActiveBitDepth);

                const expectedTotalBitsForN = BigInt(expectedN) * BigInt(currentActiveBitDepth);
                const actualBytesNeededForN = Number((expectedTotalBitsForN + 7n) / 8n);

                if (arrayBuffer.byteLength < actualBytesNeededForN && expectedN > 0) {
                     showErrorModal("Load Warning", `File is smaller (${arrayBuffer.byteLength} bytes) than expected (${actualBytesNeededForN} bytes) for ${expectedN} elements of ${currentActiveBitDepth}-bits. Processing available data.`);
                }
                
                const byteArray = new Uint8Array(arrayBuffer);
                const loadedSeq = []; 
                let bitBuffer = 0n;
                let bitBufferLen = 0;
                let byteIndex = 0;

                for (let i = 0; i < expectedN; i++) {
                    let currentElementVal = 0n;
                    let bitsReadForElement = 0;
                    
                    while(bitsReadForElement < currentActiveBitDepth) {
                        if (bitBufferLen < (currentActiveBitDepth - bitsReadForElement) && byteIndex < byteArray.length) {
                            bitBuffer = (bitBuffer << 8n) | BigInt(byteArray[byteIndex++]);
                            bitBufferLen += 8;
                        } else if (bitBufferLen === 0 && byteIndex >= byteArray.length) {
                             if (bitsReadForElement > 0) { 
                                currentElementVal <<= BigInt(currentActiveBitDepth - bitsReadForElement);
                                console.warn(`Partial element read for element ${i+1} (index ${i}) due to EOF. Padded with zeros.`);
                             } else if (loadedSeq.length < expectedN) {
                                 throw new Error(`Unexpected end of file while trying to read element ${i + 1}. Read ${loadedSeq.length} full elements.`);
                             }
                             bitsReadForElement = currentActiveBitDepth; 
                             break; 
                        }

                        const bitsToTake = Math.min(bitBufferLen, currentActiveBitDepth - bitsReadForElement);
                        if (bitsToTake <= 0) { // Should only happen if file ends precisely or bitBufferLen becomes 0 unexpectedly
                            if (bitBufferLen === 0 && byteIndex >= byteArray.length && bitsReadForElement < currentActiveBitDepth) {
                                // No more bits anywhere, pad current element if partially read
                                if (bitsReadForElement > 0) {
                                    currentElementVal <<= BigInt(currentActiveBitDepth - bitsReadForElement);
                                }
                                bitsReadForElement = currentActiveBitDepth; // Mark as "done" for this element
                            }
                            break; 
                        }

                        const shiftForChunk = BigInt(bitBufferLen - bitsToTake);
                        const chunkMask = (1n << BigInt(bitsToTake)) - 1n;
                        const valueChunk = (bitBuffer >> shiftForChunk) & chunkMask;
                        
                        currentElementVal = (currentElementVal << BigInt(bitsToTake)) | valueChunk;
                        
                        bitBufferLen -= bitsToTake;
                        bitsReadForElement += bitsToTake;
                    }
                    
                    if (bitsReadForElement < currentActiveBitDepth && i < expectedN ) { 
                        if (bitsReadForElement > 0) { 
                             currentElementVal <<= BigInt(currentActiveBitDepth - bitsReadForElement); 
                             loadedSeq.push(currentElementVal);
                             console.warn(`Element ${loadedSeq.length} was partial (read ${bitsReadForElement} of ${currentActiveBitDepth} bits) due to EOF and was padded.`);
                        }
                        console.warn(`File ended before all ${expectedN} elements could be read. Loaded ${loadedSeq.length} elements.`);
                        break; 
                    }
                    if (bitsReadForElement === currentActiveBitDepth) {
                        loadedSeq.push(currentElementVal);
                    }
                }
                
                if (loadedSeq.length < expectedN && expectedN > 0) { 
                    showErrorModal("Load Warning", `Read ${loadedSeq.length} elements, but filename expected N=${expectedN}. File might be truncated or data corrupted.`);
                }

                lastDirectInputSequence = loadedSeq.slice(); 
                await appStateWasm.setSequenceData(loadedSeq, currentActiveBitDepth); 
                sourceOfChange = 'rawBinaryUpload';
                updateAllViews();
            } catch (e) { showErrorModal("Load Binary Error", e.message); console.error(e); } finally { hideLoader(); dom.loadSequenceRawBinaryInput.value = ''; }
        };
        reader.onerror = () => { showErrorModal("File Read Error", "Could not read selected binary file."); hideLoader(); dom.loadSequenceRawBinaryInput.value = ''; };
        reader.readAsArrayBuffer(file);
    });

    async function initializeApp() {
        console.log("Attempting to initialize application...");
        showLoader("Initializing Application...", true);
        dom.charSetSizeDisplay.textContent = CHAR_SET_Array.length;
        dom.sequenceBitDepthSelect.value = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH.toString();
        currentActiveBitDepth = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH; 
        updateSequenceInputPlaceholderAndTitle(currentActiveBitDepth);
        dom.customBitDepthInput.min = CONFIG.MIN_BIT_DEPTH;
        dom.customBitDepthInput.max = CONFIG.MAX_BIT_DEPTH;

        try {
            console.log("Calling init()...");
            await init(); 
            console.log("init() successful.");

            console.log("Creating AppState instance...");
            appStateWasm = new AppState(); 
            console.log("AppState instance created:", appStateWasm);

            sourceOfChange = 'initialLoad';
            console.log("Calling updateAllViews() for initial load...");
            await updateAllViews(); 
            console.log("Initial updateAllViews() complete.");

        } catch (e) {
            console.error("FAILED to load WASM module or initialize AppState:", e);
            showErrorModal("Initialization Error", `Failed to load application: ${e.message || e.toString()}`);
        } finally { 
             hideLoader();
             console.log("Initialization routine finished.");
        }
    }
    window.addEventListener('load', initializeApp);
</script>
</body>
</html>
