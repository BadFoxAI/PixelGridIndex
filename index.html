--- START OF FILE index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Data Interconverter (Core)</title>
  <style>
    :root { /* CSS Variables */
      --primary-bg: #f4f6f8; --secondary-bg: #ffffff; --text-color: #2c3e50; --label-color: #5a6573;
      --input-border: #ced4da; --input-focus-border: #007bff; --accent-color: #007bff;
      --accent-hover-color: #0056b3; --danger-color: #e74c3c; --shadow-color: rgba(0,0,0,0.06);
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      --monospace-font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
      --container-max-width: 1200px;
      --controls-max-width: 430px; --border-radius: 5px;
    }
    html, body { height:100%; margin:0; }
    body { font-family:var(--font-family); background-color:var(--primary-bg); color:var(--text-color); display:flex; flex-direction:column; font-size:15px; line-height:1.65; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    .container { display:flex; flex-direction:column; flex-grow:1; max-width:var(--container-max-width); margin:0 auto; width:100%; }
    header { background:var(--accent-color); color:white; padding:12px 20px; text-align:center; box-shadow:0 2px 3px var(--shadow-color); flex-shrink:0; }
    header h1 { margin:0; font-size:1.5em; font-weight:500; }
    main { display:flex; flex-grow:1; padding:15px; gap:15px; }
    .panel { background-color:var(--secondary-bg); padding:20px; border-radius:var(--border-radius); box-shadow:0 1px 2px var(--shadow-color); display:flex; flex-direction:column; gap:15px; overflow-y:auto; scrollbar-width:thin; scrollbar-color:var(--input-border) var(--secondary-bg); }
    .panel::-webkit-scrollbar { width:8px; } .panel::-webkit-scrollbar-track { background:var(--secondary-bg); } .panel::-webkit-scrollbar-thumb { background-color:var(--input-border); border-radius:4px; border:2px solid var(--secondary-bg); }
    
    .controls-section { flex:1 1 45%; min-width:300px; }
    .sequence-panel { flex:1 1 55%; min-width:300px; }

    @media (max-width:992px) { 
        main { 
            flex-direction:column; 
            overflow-y:auto; 
            height:auto; 
        }
        .controls-section { order: 1; } 
        .sequence-panel { order: 2; }
    }
    @media (max-width:768px) { 
      .container{padding:0;} 
      header{border-radius:0;} 
    }

    h2, h3 { margin-top:0; color:var(--accent-hover-color); border-bottom:1px solid #e8e8e8; padding-bottom:8px; font-size:1.25em; font-weight:500; }
    h3 { font-size: 1.1em; margin-bottom: 10px; }
    .control-group label { margin-bottom:5px; font-weight:500; color:var(--label-color); font-size:0.9em; }
    .control-group input[type="text"], .control-group input[type="number"], .control-group input[type="file"], .control-group textarea, .control-group select, .control-group button { padding:9px 10px; font-size:0.9em; border-radius:calc(var(--border-radius) - 1px); border:1px solid var(--input-border); box-sizing:border-box; width:100%; }
    .control-group button { background-color:var(--accent-color); color:white; cursor:pointer; transition:background-color 0.2s ease; }
    .control-group button:hover:not(:disabled) { background-color:var(--accent-hover-color); } .control-group button:disabled { background-color:#ccc; cursor:not-allowed; }
    .control-group input[type="text"]:focus, .control-group input[type="number"]:focus, .control-group textarea:focus, .control-group select:focus { border-color:var(--input-focus-border); outline:none; box-shadow:0 0 0 0.15rem rgba(0,123,255,0.2); }
    .control-group textarea { min-height:100px; resize:vertical; font-family:var(--monospace-font-family); white-space:pre-wrap; }
    .control-group small { font-size:0.75em; color:#888; margin-top:5px; display:block; }
    #sequencePanelInfo { font-size: 0.85em; color: #666; margin-top: 10px;}
    .inline-input-group { display: flex; gap: 10px; align-items: center; }
    .inline-input-group input[type="number"] { flex-grow: 1; }
    .inline-input-group button { flex-shrink: 0; width: auto; padding: 9px 15px;}

    .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.45); justify-content:center; align-items:center; }
    .modal-content { background-color:#fefefe; margin:auto; padding:25px; border:1px solid #bbb; width:90%; max-width:420px; border-radius:var(--border-radius); text-align:center; box-shadow:0 4px 15px rgba(0,0,0,0.2); }
    .modal-content h3 { margin-top:0; margin-bottom:12px; font-size:1.2em; color:var(--accent-hover-color); } .modal-content p { font-size:0.95em; margin-bottom:20px; line-height:1.5; }
    .modal-buttons button { margin-top:10px; padding:9px 18px; background-color:var(--accent-color); color:white; border:none; border-radius:calc(var(--border-radius) - 1px); cursor:pointer; font-size:0.9em; transition:background-color 0.2s ease;}
    .modal-buttons button:hover { background-color:var(--accent-hover-color); }
    #loadingOverlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.65); z-index:2000; justify-content:center; align-items:center; flex-direction:column; color:white; font-size:1.2em; text-align:center; }
    #loadingOverlay .spinner { border:8px solid #f3f3f3; border-top:8px solid var(--accent-color); border-radius:50%; width:60px; height:60px; animation:spin 1s linear infinite; margin-top:20px; }
    @keyframes spin { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
  </style>
</head>
<body>
  <div class="container">
    <header><h1>Data Interconverter (Core)</h1></header>
    <main>
      <section class="panel controls-section">
        <h2>Input & Controls</h2>
        <div class="control-group"> <label for="canonicalIndexInput">Canonical Index (BigInt):</label> <textarea id="canonicalIndexInput" rows="3" placeholder="0"></textarea> <small>Arbitrary-precision non-negative integer. Non-digits are ignored.</small> </div>
        <div class="control-group"> <label for="textInput">Text Data:</label> <textarea id="textInput" placeholder="Enter text..."></textarea> <small>Uses a programmer-focused character set (<span id="charSetSizeDisplay">0</span> chars).</small> </div>
      </section>

      <section class="panel sequence-panel">
        <h2>Numerical Sequence (<span id="sequenceBitDepthDisplay">24</span>-bit elements)</h2>
        
        <div class="control-group">
            <label for="sequenceBitDepthSelect">Preset Element Bit Depth:</label>
            <select id="sequenceBitDepthSelect">
                <option value="1">1-bit (0 to 1)</option>
                <option value="2">2-bit (0 to 3)</option>
                <option value="4">4-bit (0 to 15)</option>
                <option value="8">8-bit (0 to 255)</option>
                <option value="12">12-bit (0 to 4,095)</option>
                <option value="16">16-bit (0 to 65,535)</option>
                <option value="24" selected>24-bit (0 to 16,777,215)</option>
                <option value="32">32-bit (0 to 4,294,967,295)</option>
                <option value="48">48-bit</option>
                <option value="56">56-bit</option>
                <option value="64">64-bit</option>
                <option value="custom">Custom...</option> 
            </select>
        </div>

        <div class="control-group" id="customBitDepthGroup" style="display: none;">
            <label for="customBitDepthInput">Custom Element Bit Depth (1-64):</label>
            <div class="inline-input-group">
                <input type="number" id="customBitDepthInput" min="1" max="64" value="24">
                <button id="applyCustomBitDepthButton">Apply</button>
            </div>
        </div>

        <div class="control-group">
            <label for="sequenceInput">Sequence (Input / Canonical Output):</label>
            <textarea id="sequenceInput" placeholder="e.g., ..."></textarea>
            <small>Comma-separated values. Reflects CI as sequence of numbers with selected bit depth.</small>
        </div>
        <div id="sequencePanelInfo">Canonical Length: <span id="sequenceCanonicalLengthDisplay">0</span> elements</div>
        
        <div class="control-group" style="margin-top: auto;">
             <button id="saveSequenceRawBinaryButton">Save Sequence as Raw Binary</button>
        </div>
        <div class="control-group">
            <label for="loadSequenceRawBinaryInput">Load Sequence from Raw Binary:</label>
            <input type="file" id="loadSequenceRawBinaryInput" accept=".seqbin,.bin,.dat,application/octet-stream">
            <small>Filename should contain _N<length>_B<bit_depth> metadata (e.g., _B24).</small>
        </div>
      </section>
    </main>
    <footer> <p>Data Interconverter (Core)</p> </footer>
  </div>
  <div class="modal" id="errorModalElement"> <div class="modal-content"> <h3 id="errorModalTitleElement">Notification</h3> <p id="errorModalMessageElement"></p> <div class="modal-buttons"> <button id="errorModalOkButtonElement">OK</button> </div> </div> </div>
  <div id="loadingOverlay"> <p id="loadingMessage">Processing...</p> <div class="spinner"></div> </div>

<script type="module">
    import init, { AppState } from './rust-wasm-lib/pkg/data_interconverter_wasm.js';

    const CONFIG = {
        CHAR_SET_STRING: " \n\t\r" + "abcdefghijklmnopqrstuvwxyz" + "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "0123456789" + "!\"#$%&'()*+,-./:;<=>?@" + "[\\]^_`{|}~" + "←↑→↓↔" + "∑√≈≠≤≥÷±∞" + "€₹₽£¥₩" + "¡¢£¤¥¦§¨©ª«¬®¯°±²³´µ¶·¸¹º»¼½¾¿" + "ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞß" + "àáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        DEFAULT_SEQUENCE_BIT_DEPTH: 24,
        MIN_BIT_DEPTH: 1, // ADDED
        MAX_BIT_DEPTH: 64, // ADDED (for now, before Vec<BigInt> elements in Rust)
        DEBOUNCE_DELAY_INPUT: 350, DEBOUNCE_DELAY_TEXT_AREA: 400, LOADER_FLICKER_THRESHOLD: 300,
    };
    const CHAR_SET_Array = Array.from(new Set(CONFIG.CHAR_SET_STRING.split(''))).sort();

    const dom = {
        canonicalIndexInput: document.getElementById('canonicalIndexInput'),
        textInput: document.getElementById('textInput'),
        charSetSizeDisplay: document.getElementById('charSetSizeDisplay'),
        
        sequenceBitDepthSelect: document.getElementById('sequenceBitDepthSelect'),
        customBitDepthGroup: document.getElementById('customBitDepthGroup'), // ADDED
        customBitDepthInput: document.getElementById('customBitDepthInput'), // ADDED
        applyCustomBitDepthButton: document.getElementById('applyCustomBitDepthButton'), // ADDED
        sequenceBitDepthDisplay: document.getElementById('sequenceBitDepthDisplay'),
        sequenceInput: document.getElementById('sequenceInput'),
        sequenceCanonicalLengthDisplay: document.getElementById('sequenceCanonicalLengthDisplay'),
        saveSequenceRawBinaryButton: document.getElementById('saveSequenceRawBinaryButton'),
        loadSequenceRawBinaryInput: document.getElementById('loadSequenceRawBinaryInput'),
        
        errorModal: { el: document.getElementById('errorModalElement'), title: document.getElementById('errorModalTitleElement'), message: document.getElementById('errorModalMessageElement'), okButton: document.getElementById('errorModalOkButtonElement') },
        loadingOverlay: document.getElementById('loadingOverlay'),
        loadingMessage: document.getElementById('loadingMessage'),
    };

    let appStateWasm;
    let sourceOfChange = 'initialLoad';
    let lastDirectInputSequence = null;
    let currentActiveBitDepth = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH; // ADDED: Track active bit depth

    function showErrorModal(title, message) { dom.errorModal.title.textContent = title; dom.errorModal.message.textContent = message; dom.errorModal.el.style.display = 'flex'; }
    dom.errorModal.okButton.onclick = () => { dom.errorModal.el.style.display = 'none'; };
    window.addEventListener('click', (event) => { if (event.target === dom.errorModal.el) dom.errorModal.el.style.display = 'none'; });
    function debounce(func, delay) { let timeout; return function (...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; }
    let generalUpdateLoaderTimeoutId = null;
    function showLoader(message = "Processing...", forceImmediate = false) { clearTimeout(generalUpdateLoaderTimeoutId); if (forceImmediate) { dom.loadingMessage.textContent = message; dom.loadingOverlay.style.display = 'flex'; } else { generalUpdateLoaderTimeoutId = setTimeout(() => { dom.loadingMessage.textContent = message; dom.loadingOverlay.style.display = 'flex'; }, CONFIG.LOADER_FLICKER_THRESHOLD); } }
    function hideLoader() { clearTimeout(generalUpdateLoaderTimeoutId); dom.loadingOverlay.style.display = 'none'; }
    function safeParseBigInt(str) { try { if (typeof str !== 'string') str = String(str); const numericStr = str.replace(/[^0-9]/g, ''); return numericStr === "" ? 0n : BigInt(numericStr); } catch (e) { return null; } }

    function updateSequenceInputPlaceholderAndTitle(bitDepth) {
        dom.sequenceBitDepthDisplay.textContent = bitDepth;
        const maxVal = (2 ** bitDepth) - 1;
        // Use BigInt for maxVal if bitDepth > 53 for accurate string representation
        const maxValStr = bitDepth > 53 ? (2n ** BigInt(bitDepth) - 1n).toString() : maxVal.toString();
        dom.sequenceInput.placeholder = `e.g., ${maxValStr}, ${maxVal > 0 ? Math.floor(maxVal / 2) : 0}, ... (0 to ${maxValStr})`;
    }
    
    function getValidatedBitDepth() {
        let bitDepth = parseInt(dom.customBitDepthInput.value, 10);
        if (isNaN(bitDepth) || bitDepth < CONFIG.MIN_BIT_DEPTH || bitDepth > CONFIG.MAX_BIT_DEPTH) {
            showErrorModal("Invalid Bit Depth", `Custom bit depth must be a number between ${CONFIG.MIN_BIT_DEPTH} and ${CONFIG.MAX_BIT_DEPTH}. Reverting to previous valid depth.`);
            dom.customBitDepthInput.value = currentActiveBitDepth; // Revert to last valid
            return currentActiveBitDepth;
        }
        return bitDepth;
    }

    async function renderCanonicalIndex() { /* ... no changes ... */ }
    async function renderText() { /* ... no changes ... */ }

    async function renderSequence() {
        // currentActiveBitDepth is now the source of truth for rendering
        dom.sequenceBitDepthDisplay.textContent = currentActiveBitDepth; 

        let sequenceForTextarea;
        let displayedLength;

        if (sourceOfChange === 'sequenceInput' || sourceOfChange === 'rawBinaryUpload') {
            sequenceForTextarea = lastDirectInputSequence ? [...lastDirectInputSequence] : [];
            displayedLength = sequenceForTextarea.length;
        } else {
            try {
                displayedLength = await appStateWasm.calculateMinSequenceLength(currentActiveBitDepth);
                sequenceForTextarea = await appStateWasm.getSequenceRepresentation(displayedLength, currentActiveBitDepth);
            } catch (e) {
                showErrorModal("Sequence Render Error", e.message);
                sequenceForTextarea = [`Error: ${e.message.substring(0, 50)}`];
                displayedLength = sequenceForTextarea.length;
            }
        }
        dom.sequenceInput.value = sequenceForTextarea.join(', ');
        dom.sequenceCanonicalLengthDisplay.textContent = displayedLength;
    }

    async function updateAllViews() { /* ... no changes to this function itself ... */ }
    dom.canonicalIndexInput.addEventListener('input', debounce(async () => { /* ... no changes ... */ }));
    dom.textInput.addEventListener('input', debounce(async () => { /* ... no changes ... */ }));

    function handleBitDepthChange(newBitDepth) {
        if (newBitDepth !== currentActiveBitDepth) {
            currentActiveBitDepth = newBitDepth;
            sourceOfChange = 'bitDepthChange';
            lastDirectInputSequence = null;
            updateSequenceInputPlaceholderAndTitle(currentActiveBitDepth);
            updateAllViews();
        }
    }

    dom.sequenceBitDepthSelect.addEventListener('change', () => {
        const selectedValue = dom.sequenceBitDepthSelect.value;
        if (selectedValue === "custom") {
            dom.customBitDepthGroup.style.display = 'block';
            dom.customBitDepthInput.value = currentActiveBitDepth; // Pre-fill with current
            dom.customBitDepthInput.focus();
        } else {
            dom.customBitDepthGroup.style.display = 'none';
            handleBitDepthChange(parseInt(selectedValue, 10));
        }
    });

    dom.applyCustomBitDepthButton.addEventListener('click', () => {
        const customDepth = getValidatedBitDepth();
        // Update the preset dropdown if custom matches a preset, or keep "Custom..." selected
        let matchedPreset = false;
        for (let option of dom.sequenceBitDepthSelect.options) {
            if (parseInt(option.value, 10) === customDepth) {
                dom.sequenceBitDepthSelect.value = option.value;
                dom.customBitDepthGroup.style.display = 'none';
                matchedPreset = true;
                break;
            }
        }
        if (!matchedPreset) {
             // Keep custom selected if no preset matches, or add it as a temporary option
            // For simplicity now, if it doesn't match a preset, we assume "Custom..." stays selected
            // and the custom group remains visible if we want immediate further custom changes.
            // Or hide it: dom.customBitDepthGroup.style.display = 'none';
            // And ensure the dropdown reflects "Custom..." if that's the active mode.
            // This part can be refined for UX. For now, if a valid custom is applied, it's used.
            // To ensure "Custom..." stays selected if the value doesn't match a preset:
            if (dom.sequenceBitDepthSelect.value !== "custom") { // If user selected a preset then typed custom
                 let customOpt = Array.from(dom.sequenceBitDepthSelect.options).find(o => o.value === "custom");
                 if(customOpt) dom.sequenceBitDepthSelect.value = "custom";
            }
        }
        handleBitDepthChange(customDepth);
    });
     dom.customBitDepthInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            event.preventDefault(); // Prevent form submission if it were in a form
            dom.applyCustomBitDepthButton.click();
        }
    });


    dom.sequenceInput.addEventListener('input', debounce(async () => {
        const sequenceStr = dom.sequenceInput.value.trim();
        // currentActiveBitDepth is the source of truth
        const maxValForBitDepth = (2 ** currentActiveBitDepth) - 1; 
        const maxValStr = currentActiveBitDepth > 53 ? (2n ** BigInt(currentActiveBitDepth) - 1n).toString() : maxValForBitDepth.toString();

        try {
            let parsedSequence = [];
            if (sequenceStr !== "") {
                parsedSequence = sequenceStr.split(',').map(s => s.trim()).filter(s => s !== "").map(sVal => {
                    const num = Number(sVal); // JS Numbers used for input elements
                    if (isNaN(num) || num < 0 || num > maxValForBitDepth) { // Compare with JS Number max
                        throw new Error(`Invalid sequence value: '${sVal}'. Must be a number between 0 and ${maxValStr} for ${currentActiveBitDepth}-bit elements.`);
                    }
                    return num;
                });
            }
            lastDirectInputSequence = parsedSequence.slice();
            await appStateWasm.setSequenceData(parsedSequence, currentActiveBitDepth);
            sourceOfChange = 'sequenceInput';
            updateAllViews();
        } catch (e) {
            showErrorModal("Sequence Input Error", e.message);
        }
    }, CONFIG.DEBOUNCE_DELAY_TEXT_AREA));

    dom.saveSequenceRawBinaryButton.addEventListener('click', async () => {
        // currentActiveBitDepth is the source of truth
        const currentMinLength = await appStateWasm.calculateMinSequenceLength(currentActiveBitDepth);
        const sequenceToSave = await appStateWasm.getSequenceRepresentation(currentMinLength, currentActiveBitDepth);

        const currentCanonicalIndex = await appStateWasm.getCanonicalIndex();
        if ((!sequenceToSave || sequenceToSave.length === 0) && currentCanonicalIndex !== 0n) { /* ... */ }
        
        const numElements = sequenceToSave.length;
        const bytesPerElement = Math.ceil(currentActiveBitDepth / 8);
        showLoader("Generating Raw Binary File...", true);
        setTimeout(() => {
            try {
                const buffer = new ArrayBuffer(numElements * bytesPerElement);
                const dataView = new DataView(buffer);
                let offset = 0;
                for (const val of sequenceToSave) { // val is a JS Number from WASM Vec<u32> or Vec<u64>
                    // Write bytes from most significant to least significant
                    for (let j = 0; j < bytesPerElement; j++) {
                        const shiftAmount = (bytesPerElement - 1 - j) * 8;
                        dataView.setUint8(offset++, (Number(val) >> shiftAmount) & 0xFF);
                    }
                }
                const blob = new Blob([buffer], { type: 'application/octet-stream' });
                const link = document.createElement('a');
                link.download = `sequence_N${numElements}_B${currentActiveBitDepth}_${Date.now()}.seqbin`;
                link.href = URL.createObjectURL(blob); document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href);
            } catch (e) { showErrorModal("Save Binary Error", e.message); } finally { hideLoader(); }
        }, 10);
    });

    dom.loadSequenceRawBinaryInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        showLoader("Loading Raw Binary File...", true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            showLoader("Processing Binary Data...", true);
            try {
                const buffer = e.target.result;
                if (!(buffer instanceof ArrayBuffer)) { throw new Error("File content is not an ArrayBuffer."); }

                let expectedN = -1; let expectedB_fromFile = -1;
                const matchN = file.name.match(/_N(\d+)_/); 
                const matchB = file.name.match(/_B(\d+)_/);
                
                if (matchN && matchN[1]) expectedN = parseInt(matchN[1], 10);
                if (matchB && matchB[1]) expectedB_fromFile = parseInt(matchB[1], 10);

                if (isNaN(expectedN) || expectedN < 0) { throw new Error("Filename metadata for N is missing/invalid."); }
                if (isNaN(expectedB_fromFile) || expectedB_fromFile < CONFIG.MIN_BIT_DEPTH || expectedB_fromFile > CONFIG.MAX_BIT_DEPTH) {
                    throw new Error(`Filename metadata for B is missing or invalid (e.g., _B24). Supported: ${CONFIG.MIN_BIT_DEPTH}-${CONFIG.MAX_BIT_DEPTH}. Got: ${expectedB_fromFile}`);
                }
                
                currentActiveBitDepth = expectedB_fromFile; // Set active depth from file
                dom.sequenceBitDepthSelect.value = Array.from(dom.sequenceBitDepthSelect.options).some(o => o.value == currentActiveBitDepth) ? currentActiveBitDepth : "custom";
                if (dom.sequenceBitDepthSelect.value === "custom") {
                    dom.customBitDepthGroup.style.display = 'block';
                    dom.customBitDepthInput.value = currentActiveBitDepth;
                } else {
                    dom.customBitDepthGroup.style.display = 'none';
                }
                updateSequenceInputPlaceholderAndTitle(currentActiveBitDepth);
                
                const bytesPerElement = Math.ceil(currentActiveBitDepth / 8);
                if (buffer.byteLength === 0 && expectedN === 0) { /* fine */ }
                else if (buffer.byteLength !== expectedN * bytesPerElement) { /* ... error modal ... */ }

                const dataView = new DataView(buffer);
                const loadedSeq = [];
                const numElementsToRead = Math.min(expectedN, Math.floor(buffer.byteLength / bytesPerElement));

                for (let i = 0; i < numElementsToRead; i++) {
                    const offset = i * bytesPerElement;
                    if (offset + bytesPerElement > buffer.byteLength) break;
                    let val = 0;
                    // Read bytes from most significant to least significant
                    for (let j = 0; j < bytesPerElement; j++) {
                        val = (val * 256) + dataView.getUint8(offset + j);
                    }
                    loadedSeq.push(val);
                }

                if (loadedSeq.length < expectedN && expectedN > 0 && numElementsToRead < expectedN) { /* ... error modal ... */ }

                lastDirectInputSequence = loadedSeq.slice();
                await appStateWasm.setSequenceData(loadedSeq, currentActiveBitDepth);
                sourceOfChange = 'rawBinaryUpload';
                updateAllViews();
            } catch (e) { showErrorModal("Load Binary Error", e.message); } finally { hideLoader(); dom.loadSequenceRawBinaryInput.value = ''; }
        };
        reader.onerror = () => { /* ... */ };
        reader.readAsArrayBuffer(file);
    });

    async function initializeApp() {
        showLoader("Initializing Application...", true);
        dom.charSetSizeDisplay.textContent = CHAR_SET_Array.length;
        dom.sequenceBitDepthSelect.value = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH;
        currentActiveBitDepth = CONFIG.DEFAULT_SEQUENCE_BIT_DEPTH; // Initialize active bit depth
        updateSequenceInputPlaceholderAndTitle(currentActiveBitDepth);

        try {
            await init();
            appStateWasm = new AppState();
            sourceOfChange = 'initialLoad';
            await updateAllViews(); 
        } catch (e) { /* ... */ } 
        finally { hideLoader(); }
    }
    window.addEventListener('load', initializeApp);
</script>
</body>
</html>
